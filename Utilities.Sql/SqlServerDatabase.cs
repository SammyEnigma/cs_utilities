/* See UNLICENSE.txt file for license details. */

using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Linq;
using System.Xml;

using Utilities.Core;

namespace Utilities.Sql
{
  /// <summary>
  /// The text generated by some of the <see cref="Utilities.Sql.Column">Column</see> class's properties can include
  /// a comment indicating whether or not that column is a primary or foreign key.
  /// This enumeration is used to turn that capability on or off.
  /// </summary>
  public enum IncludeKeyIdentificationComment { No, Yes }

  public enum IsTargetLanguageCaseSensitive { No, Yes }

  /// <summary>
  /// .Net languages can handle an SQL Server column of type 'xml' in three ways:
  /// as a <see cref="System.String">String</see>, as an <see cref="System.Xml.XmlDocument">XmlDocument</see>,
  /// or as an <see cref="System.Xml.Linq.XDocument">XDocument</see>.
  /// </summary>
  public enum XmlSystem
  {
    /// <summary>
    /// Create code to handle the xml column as a <see cref="System.String">String</see>.
    /// </summary>
    AsString,
    
    /// <summary>
    /// Create code to handle the xml column as a <see cref="System.Xml.XmlDocument">XmlDocument</see>.
    /// </summary>
    NonLinq_XmlDocument,
    
    /// <summary>
    /// Create code to handle the xml column as a <see cref="System.Xml.Linq.XDocument">XDocument</see>.
    /// </summary>
    Linq_XDocument
  }

  public enum TargetLanguage { CSharp, VisualBasic, FSharp }

  /// <summary>
  /// An instance of this class is passed into the <see cref="Utilities.Sql.Server">Server</see> constructor.
  /// </summary>
  public class Configuration
  {
    /// <summary>
    /// A valid <see cref="System.Data.SqlClient.SqlConnection">SqlConnection</see>.
    /// <para>The connection must be open before being passed to the <see cref="Utilities.Sql.Server">Server</see> constructor.</para>
    /// </summary>
    public SqlConnection Connection { get; set; }

    /// <summary>
    /// Specify what kind of CLR datatype (String, XmlDocument, or XDocument) should be used to handle
    /// SQL Server columns of type 'xml'.
    /// </summary>
    public XmlSystem XmlSystem { get; set; }

    public TargetLanguage TargetLanguage { get; set; }

    public IsTargetLanguageCaseSensitive IsTargetLanguageCaseSensitive { get; set; }
  }

  public abstract class SqlAbstractBase
  {
    private List<String> _csharpKeywords =
      new List<String>()
      {
        /* Keywords. */
        "abstract",
        "as",
        "base",
        "bool",
        "break",
        "byte",
        "case",
        "catch",
        "char",
        "checked",
        "class",
        "cons",
        "continue",
        "decimal",
        "default",
        "delegate",
        "do",
        "double",
        "else",
        "enum",
        "event",
        "explicit",
        "extern",
        "false",
        "finally",
        "fixed",
        "float",
        "for",
        "foreach",
        "goto",
        "if",
        "implicit",
        "in",
        "int",
        "interface",
        "internal",
        "is",
        "lock",
        "long",
        "namespace",
        "new",
        "null",
        "object",
        "operator",
        "out",
        "override",
        "params",
        "private",
        "protected",
        "public",
        "readonly",
        "ref",
        "return",
        "sbyte",
        "sealed",
        "short",
        "sizeof",
        "stackalloc",
        "static",
        "string",
        "struct",
        "switch",
        "this",
        "throw",
        "true",
        "try",
        "typeof",
        "uint",
        "ulong",
        "unchecked",
        "unsafe",
        "ushort",
        "using",
        "virtual",
        "void",
        "volatile",
        "while",

        /* Contextual keywords and reserved words. */
        "alias",
        "ascending",
        "by",
        "const",
        "descending",
        "equals",
        "field",
        "from",
        "get",
        "group",
        "into",
        "join",
        "let",
        "method",
        "on",
        "orderby",
        "param",
        "partial",
        "property",
        "select",
        "set",
        "type",
        "var",
        "where",
        "yield"
      };

    private List<String> _fsharpKeywords =
      new List<String>()
      {
        /* Keywords. */
        "abstract",
        "and",
        "as",
        "assert",
        "base",
        "begin",
        "class",
        "default",
        "delegate",
        "do",
        "done",
        "downcast",
        "downto",
        "elif",
        "else",
        "end",
        "exception",
        "extern",
        "false",
        "finally",
        "for",
        "fun",
        "function",
        "global",
        "if",
        "in",
        "inherit",
        "inline",
        "interface",
        "internal",
        "lazy",
        "let",
        "match",
        "member",
        "module",
        "mutable",
        "namespace",
        "new",
        "null",
        "of",
        "open",
        "or",
        "override",
        "private",
        "public",
        "rec",
        "return",
        "sig",
        "static",
        "struct",
        "then",
        "to",
        "true",
        "try",
        "type",
        "upcast",
        "use",
        "val",
        "void",
        "when",
        "while",
        "with",
        "yield",

        /* Reserved words. */
        "atomic",
        "break",
        "checked",
        "component",
        "const",
        "constraint",
        "constructor",
        "continue",
        "eager",
        "fixed",
        "fori",
        "functor",
        "include",
        "measure",
        "method",
        "mixin",
        "object",
        "parallel",
        "params",
        "process",
        "protected",
        "pure",
        "recursive",
        "sealed",
        "tailcall",
        "trait",
        "virtual",
        "volatile"
      };

    private List<String> _visualBasicKeywords =
      new List<String>()
      {
        /* Keywords. */
        "AddHandler",
        "AddressOf",
        "Alias",
        "And",        "AndAlso",
        "As",
        "Boolean",
        "ByRef",        "Byte",
        "ByVal",
        "Call",
        "Case",        "Catch",
        "CBool",
        "CByte",
        "CChar",        "CDate",
        "CDbl",
        "CDec",
        "Char",        "CInt",
        "Class",
        "CLng",
        "CObj",        "Const",
        "Continue",
        "CSByte",
        "CShort",        "CSng",
        "CStr",
        "CType",
        "CUInt",        "CULng",
        "CUShort",
        "Date",
        "Decimal",        "Declare",
        "Default",
        "Delegate",
        "Dim",        "DirectCast",
        "Do",
        "Double",
        "Each",        "Else",
        "ElseIf",
        "End",
        "EndIf",        "Enum",
        "Erase",
        "Error",
        "Event",        "Exit",
        "False",
        "Finally",
        "For",        "Friend",
        "Function",
        "Get",
        "GetType",        "GetXmlNamespace",
        "Global",
        "GoSub",
        "GoTo",        "Handles",
        "If",
        "Implements",
        "Imports",        "In",
        "Inherits",
        "Integer",
        "Interface",        "Is",
        "IsNot",
        "Let",
        "Lib",        "Like",
        "Long",
        "Loop",
        "Me",        "Mod",
        "Module",
        "MustInherit",
        "MustOverride",        "MyBase",
        "MyClass",
        "Namespace",
        "Narrowing",        "New",
        "Next",
        "Not",
        "Nothing",        "NotInheritable",
        "NotOverridable",
        "Object",
        "Of",        "On",
        "Operator",
        "Option",
        "Optional",        "Or",
        "OrElse",
        "Overloads",
        "Overridable",        "Overrides",
        "ParamArray",
        "Partial",
        "Private",        "Property",
        "Protected",
        "Public",
        "RaiseEvent",        "ReadOnly",
        "ReDim",
        "REM",
        "RemoveHandler",        "Resume",
        "Return",
        "SByte",
        "Select",        "Set",
        "Shadows",
        "Shared",
        "Short",        "Single",
        "Static",
        "Step",
        "Stop",        "String",
        "Structure",
        "Sub",
        "SyncLock",        "Then",
        "Throw",
        "To",
        "True",        "Try",
        "TryCast",
        "TypeOf",
        "UInteger",        "ULong",
        "UShort",
        "Using",
        "Variant",        "Wend",
        "When",
        "While",
        "Widening",        "With",
        "WithEvents",
        "WriteOnly",
        "Xor",
        /* Sometimes treated like keywords, but not really keywords. */
        "Aggregate",
        "AM",
        "Ansi",
        "Async",
        "Auto",
        "Await",
        "Binary",
        "By",
        "Compare",
        "Custom",
        "Distinct",
        "Equals",
        "From",
        "Group",
        "Infer",
        "Into",
        "IsFalse",
        "IsTrue",
        "Iterator",
        "Join",
        "Let",
        "Mid",
        "Off",
        "Order",
        "Out",
        "PM",
        "Preserve",
        "Select",
        "Skip",
        "Strict",
        "Take",
        "Text",
        "Unicode",
        "Until",
        "Where"
      };

    private List<String> _targetLanguageKeywords;

    protected Configuration _configuration = null;

    public SqlAbstractBase(Configuration configuration)
      : base()
    {
      this._configuration = configuration;

      switch (this._configuration.TargetLanguage)
      {
        case TargetLanguage.CSharp:
          this._targetLanguageKeywords = this._csharpKeywords;
          break;
        case TargetLanguage.FSharp:
          this._targetLanguageKeywords = this._fsharpKeywords;
          break;
        case TargetLanguage.VisualBasic:
          this._targetLanguageKeywords = this._visualBasicKeywords;
          break;
        default:
          throw new NotImplementedException(String.Format(Properties.Resources.UnknownTargetLanguageValue, this._configuration.TargetLanguage));
      }
    }

    /// <summary>
    /// Convert an SQL identifier, like a database name or column name, into a valid
    /// identifier for the target language (C#, F#, etc.) that was set in
    /// the configuration.
    /// </summary>
    /// <param name="sqlIdentifier"></param>
    /// <returns></returns>
    public String GetTargetLanguageIdentifier(String sqlIdentifier)
    {
      var result = sqlIdentifier.ToLower().Replace(" ", "_").Replace(".", "_");

      if (Char.IsDigit(result[0]))
        result = "_" + result;

      var stringComparison = 
        (this._configuration.IsTargetLanguageCaseSensitive == IsTargetLanguageCaseSensitive.Yes)
          ? StringComparison.CurrentCulture
          : StringComparison.CurrentCultureIgnoreCase;

      if (this._targetLanguageKeywords.Exists(keyword => String.Equals(keyword, result, stringComparison)))
        result = "_" + result;

      return result;
    }
  }

  public class Server : SqlAbstractBase
  {
    private Databases _databases = null;
    public Databases Databases
    {
      get
      {
        if (this._databases == null)
          this._databases = new Databases(this._configuration);

        return this._databases;
      }
    }

    public Server(Configuration configuration)
      : base(configuration)
    {
    }
  }

  public class Databases : List<Database>
  {
    /// <summary>
    /// There are usually some databases that can be ignored during code generation.
    /// <para>This property contains a list of those database names.  Modify it as needed.</para>
    /// </summary>
    public readonly List<String> IgnoredDatabaseNames = new List<String>() { "master", "model", "msdb", "tempdb", "reportserver", "reportservertempdb" };

    /// <summary>
    /// This property represents all of the database names in the server, except those in the
    /// <see cref="Utilities.Sql.Databases.IgnoredDatabaseNames">IgnoredDatabaseNames</see> list.
    /// </summary>
    public List<Database> RelevantDatabases
    {
      get
      {
        return this.Where(db => !this.IgnoredDatabaseNames.Exists(name => db.Name.ToLower() == name)).ToList();
      }
    }

    public Databases(Configuration configuration)
      : base()
    {
      var table = configuration.Connection.GetSchema("Databases");
      foreach (DataRow row in table.Rows)
        this.Add(new Database(configuration) { Name = row["database_name"].ToString() });
    }
  }

  public class Database : SqlAbstractBase
  {
    /// <summary>
    /// The database name as it appears on the database server.
    /// </summary>
    public String Name { get; set; }

    private Tables _tables = null;
    public Tables Tables
    {
      get
      {
        if (this._tables == null)
        {
          /* Treat the connection's current database as an in. */
          var previousDatabaseName = (this._configuration.Connection.Database == this.Name) ? null : this._configuration.Connection.Database;
          try
          {
            if (previousDatabaseName != null)
              this._configuration.Connection.ChangeDatabase(this.Name);

            this._tables = new Tables(this._configuration, this.Name);
          }
          finally
          {
            if (previousDatabaseName != null)
              this._configuration.Connection.ChangeDatabase(previousDatabaseName);
          }
        }

        return this._tables;
      }
    }

    public Database(Configuration configuration)
      : base(configuration)
    {
    }
  }

  public class Tables : List<Table>
  {
    public Tables(Configuration configuration, String databaseName)
      : base()
    {
      var table = configuration.Connection.GetSchema("Tables");
      foreach (DataRow row in table.Rows)
        this.Add(
          new Table(configuration)
          {
            DatabaseName = databaseName,
            SchemaName = row["table_schema"].ToString(),
            Name = row["table_name"].ToString(),
            IsView = row["table_type"].ToString().Equals("VIEW", StringComparison.InvariantCultureIgnoreCase)
          });
    }
  }

  public class Table : SqlAbstractBase
  {
    /// <summary>
    /// The table's database name as it appears on the database server.
    /// </summary>
    public String DatabaseName { get; set; }

    /// <summary>
    /// The table's schema name as it appears on the database server.
    /// </summary>
    public String SchemaName { get; set; }

    /// <summary>
    /// The table name as it appears on the database server.
    /// </summary>
    public String Name { get; set; }

    /// <summary>
    /// This class is named Table, it handles both tables and views.  This property indicates what a Table instance really contains.
    /// </summary>
    public Boolean IsView { get; set; }

    /// <summary>
    /// In SQL Server 2005 and later, a table name in a database is not necessarily unique,
    /// because the same table name can be used in different schemas.
    /// <para>This property produces a unique table identifier by combining the schema name
    /// and table name.  The two components are also rendered safe by wrapping them in 
    /// square brackets.</para>
    /// </summary>
    public String SchemaNameAndTableName
    {
      get { return String.Format("[{0}].[{1}]", this.SchemaName, this.Name); }
    }

    private String _targetLanguageTableIdentifier = null;
    /// <summary>
    /// The table name converted for use as a valid identifier in generated code.
    /// </summary>
    public String TargetLanguageTableIdentifier
    {
      get
      {
        if (this._targetLanguageTableIdentifier == null)
          this._targetLanguageTableIdentifier = this.GetTargetLanguageIdentifier(this.SchemaName) + "_" + this.GetTargetLanguageIdentifier(this.Name);

        return this._targetLanguageTableIdentifier;
      }
    }

    private Columns _columns = null;
    public Columns Columns
    {
      get
      {
        if (this._columns == null)
        {
          /* Treat the connection's current database as an in. */
          var previousDatabaseName = (this._configuration.Connection.Database == this.DatabaseName) ? null : this._configuration.Connection.Database;
          try
          {
            if (previousDatabaseName != null)
              this._configuration.Connection.ChangeDatabase(this.DatabaseName);

            this._columns = new Columns(this._configuration, this.SchemaName, this.Name, this.IsView);
          }
          finally
          {
            if (previousDatabaseName != null)
              this._configuration.Connection.ChangeDatabase(previousDatabaseName);
          }
        }

        return this._columns;
      }
    }

    public Table(Configuration configuration)
      : base(configuration)
    {
    }
  }

  public class Columns : List<Column>
  {
    private Configuration _configuration = null;

    public Columns(Configuration configuration, String schemaName, String tableName, Boolean isView)
      : base()
    {
      this._configuration = configuration;

      var sql = @"
;WITH foreign_keys_CTE (FOREIGN_KEY_TABLE, FOREIGN_KEY_COLUMN, PRIMARY_KEY_TABLE, PRIMARY_KEY_COLUMN)
AS
(
  SELECT
      FOREIGN_KEY_TABLE = OBJECT_NAME(FKC.parent_object_id),
      FOREIGN_KEY_COLUMN = C.NAME,
      PRIMARY_KEY_TABLE = OBJECT_NAME(FKC.referenced_object_id),
      PRIMARY_KEY_COLUMN = CREF.NAME
    FROM
      sys.foreign_key_columns AS FKC
      INNER JOIN sys.columns AS C ON FKC.parent_column_id = C.column_id AND FKC.parent_object_id = c.object_id
      INNER JOIN sys.columns AS CREF ON FKC.referenced_column_id = CREF.column_id AND FKC.referenced_object_id = cref.object_id
),
primary_keys_CTE (OBJECT_ID, COLUMN_ID, PRIMARY_KEY_ORDINAL)
AS
(
  SELECT
      i.object_id,
      c.column_id,
      ic.key_ordinal
    FROM
      sys.indexes AS i
      INNER JOIN sys.index_columns AS ic ON i.object_id = ic.object_id AND i.index_id = ic.index_id and i.is_primary_key = 1
      INNER JOIN sys.columns AS C ON C.[object_id] = IC.[object_id] AND c.[column_id] = ic.column_id
),
column_type_CTE (USER_TYPE_ID, SERVER_DATATYPE_NAME, BASE_SERVER_DATATYPE_NAME)
AS
(
  SELECT
      T1.user_type_id,
      SERVER_DATATYPE_NAME = UPPER(T1.name),
      BASE_SERVER_DATATYPE_NAME = UPPER(COALESCE(T2.name, T1.name))
    FROM
      sys.types AS T1
      LEFT OUTER JOIN sys.types AS T2 ON T2.user_type_id = T1.system_type_id AND T1.is_table_type = 0
)
SELECT
  DISTINCT
    S.schema_id,
    [SCHEMA_NAME] = S.[name],
    TABLE_NAME = TBL.name,
    COLUMN_NAME = C.[name],
    COLUMN_ORDINAL = C.column_id - 1,
    C.user_type_id,
    C.system_type_id,
    SERVER_DATATYPE_NAME = CT_CTE.SERVER_DATATYPE_NAME,
    BASE_SERVER_DATATYPE_NAME = CT_CTE.BASE_SERVER_DATATYPE_NAME,
    PHYSICAL_LENGTH = C.max_length,
    LOGICAL_LENGTH = 
      CASE
        WHEN ((CT_CTE.SERVER_DATATYPE_NAME = 'NCHAR') OR (CT_CTE.SERVER_DATATYPE_NAME = 'NVARCHAR')) AND (C.max_length > -1) THEN
          C.max_length / 2
        ELSE
          C.max_length
      END,
    C.[precision],
    C.scale,
    IS_NULLABLE = CASE C.is_nullable WHEN 0 THEN 'N' ELSE 'Y' END,
    IS_IDENTITY = CASE C.is_identity WHEN 0 THEN 'N' ELSE 'Y' END,
    IS_XML_DOCUMENT = CASE C.is_xml_document WHEN 0 THEN 'N' ELSE 'Y' END,
    XML_COLLECTION_NAME = COALESCE(XMLCOLL.name, ''),
    IS_PRIMARY_KEY = CASE WHEN (PK_CTE.primary_key_ordinal IS NULL) THEN 'N' ELSE 'Y' END,
    PRIMARY_KEY_ORDINAL = COALESCE(PK_CTE.primary_key_ordinal, -1),
    IS_FOREIGN_KEY = CASE WHEN (FKCTE.foreign_key_table IS NULL) THEN 'N' ELSE 'Y' END,
    PRIMARY_KEY_TABLE = COALESCE(FKCTE.primary_key_table, ''),
    PRIMARY_KEY_COLUMN = COALESCE(FKCTE.primary_key_column, '')
  FROM
    sys.schemas AS S
    INNER JOIN sys.{0} AS TBL ON TBL.schema_id = S.schema_id
    INNER JOIN sys.columns AS C ON TBL.[object_id] = C.[object_id]
    LEFT OUTER JOIN sys.xml_schema_collections AS XMLCOLL ON XMLCOLL.xml_collection_id = C.xml_collection_id
    LEFT OUTER JOIN foreign_keys_CTE AS FKCTE ON (FKCTE.foreign_key_table = TBL.[name]) AND (FKCTE.foreign_key_column = C.[name])
    LEFT OUTER JOIN primary_keys_CTE AS PK_CTE ON PK_CTE.object_id = TBL.object_id AND PK_CTE.column_id = C.column_id
    LEFT OUTER JOIN column_type_CTE AS CT_CTE ON CT_CTE.USER_TYPE_ID = C.user_type_id
  WHERE
    S.[schema_id] = SCHEMA_ID('{1}')
    AND TBL.[name] = '{2}';
";
      var select = String.Format(sql, (isView ? "views" : "tables"), schemaName, tableName);
      var table = configuration.Connection.GetDataSet(select).Tables[0];

      foreach (DataRow row in table.Rows)
      {
        this.Add(
          new Column(configuration)
          {
            Name = row["COLUMN_NAME"].ToString(),
            Ordinal = Convert.ToInt32(row["COLUMN_ORDINAL"]),
            ServerDataTypeName = row["SERVER_DATATYPE_NAME"].ToString(),
            BaseServerDataTypeName = row["BASE_SERVER_DATATYPE_NAME"].ToString(),
            PhysicalLength = Convert.ToInt32(row["PHYSICAL_LENGTH"]),
            LogicalLength = Convert.ToInt32(row["LOGICAL_LENGTH"]),
            Precision = Convert.ToInt32(row["PRECISION"]),
            Scale = Convert.ToInt32(row["SCALE"]),
            IsNullable = row["IS_NULLABLE"].ToString().AsBoolean(),
            IsIdentity = row["IS_IDENTITY"].ToString().AsBoolean(),
            IsXmlDocument = row["IS_XML_DOCUMENT"].ToString().AsBoolean(),
            XmlCollectionName = row["XML_COLLECTION_NAME"].ToString(),
            IsPrimaryKey = row["IS_PRIMARY_KEY"].ToString().AsBoolean(),
            PrimaryKeyOrdinal = Convert.ToInt32(row["PRIMARY_KEY_ORDINAL"]),
            IsForeignKey = row["IS_FOREIGN_KEY"].ToString().AsBoolean(),
            PrimaryKeyTable = row["PRIMARY_KEY_TABLE"].ToString(),
            PrimaryKeyColumn = row["PRIMARY_KEY_COLUMN"].ToString(),
          });
      }
    }

    /// <summary>
    /// Return a list of strings that can be used as a parameter declarations in a stored procedure.
    /// <para>Primary and foreign key columns may optionally be documented with a comment.</para>
    /// </summary>
    /// <example>
    /// Executing "String.Join("," + Environment.NewLine, columns.GetStoredProcedureParameters())"
    /// on the AdventureWorks2012 Person.Person table will generate this string:
    /// <code>
    /// @BusinessEntityID INT  /* primary key 1, foreign key */,
    /// @AdditionalContactInfo XML(CONTENT, AdditionalContactInfoSchemaCollection),
    /// @Demographics XML(CONTENT, IndividualSurveySchemaCollection),
    /// @EmailPromotion INT,
    /// @FirstName NAME,
    /// @LastName NAME,
    /// @MiddleName NAME,
    /// @ModifiedDate DATETIME,
    /// @NameStyle NAMESTYLE,
    /// @PersonType NCHAR(2),
    /// @rowguid UNIQUEIDENTIFIER,
    /// @Suffix NVARCHAR(10),
    /// @Title NVARCHAR(8)
    /// </code>
    /// </example>
    /// <param name="includeKeyIdentificationComment">An enum value indicating whether or not to include
    /// a comment identifying the column as a primary and/or foreign key (see example code).</param>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetStoredProcedureParameters(IncludeKeyIdentificationComment includeKeyIdentificationComment = IncludeKeyIdentificationComment.Yes)
    {
      return
        this
        .OrderByDescending(column => column.IsIdentity)
        .ThenByDescending(column => column.IsPrimaryKey)
        .ThenBy(column => column.PrimaryKeyOrdinal)
        .ThenByDescending(column => column.IsForeignKey)
        .Select(column => column.GetStoredProcedureParameterDeclaration(includeKeyIdentificationComment))
        .ToList();
    }

    /// <summary>
    /// Returns a list of strings that can be used in the SELECT clause of an SQL Server SELECT statement.
    /// </summary>
    /// <example>
    /// Executing "String.Join("," + Environment.NewLine, columns.GetSelectColumnList("T"))"
    /// on the AdventureWorks2012 Person.Person table will generate this string:
    /// <code>
    /// T.[AdditionalContactInfo],
    /// T.[BusinessEntityID],
    /// T.[Demographics],
    /// T.[EmailPromotion],
    /// T.[FirstName],
    /// T.[LastName],
    /// T.[MiddleName],
    /// T.[ModifiedDate],
    /// T.[NameStyle],
    /// T.[PersonType],
    /// T.[rowguid],
    /// T.[Suffix],
    /// T.[Title]
    /// </code>
    /// </example>
    /// <param name="tableAlias">An optional string representing a table alias that will be prepended to each column name.</param>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetSelectColumnList(String tableAlias = "")
    {
      return
        this
        .OrderBy(column => column.Name)
        .Select(column => String.Format("{0}[{1}]", (String.IsNullOrWhiteSpace(tableAlias) ? "" : tableAlias + "."), column.Name))
        .ToList();
    }

    /// <summary>
    /// Returns a list of strings that can be used in the column list of an SQL Server INSERT statement.
    /// </summary>
    /// <example>
    /// Executing "String.Join("," + Environment.NewLine, columns.GetInsertColumnList())"
    /// on the AdventureWorks2012 Person.Person table will generate this string:
    /// <code>
    /// [AdditionalContactInfo],
    /// [BusinessEntityID],
    /// [Demographics],
    /// [EmailPromotion],
    /// [FirstName],
    /// [LastName],
    /// [MiddleName],
    /// [ModifiedDate],
    /// [NameStyle],
    /// [PersonType],
    /// [rowguid],
    /// [Suffix],
    /// [Title]
    /// </code>
    /// </example>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetInsertColumnList()
    {
      return
        this
        .Where(column => !column.IsIdentity)
        .Where(column => column.CanBeUsedInInsertStatement)
        .OrderBy(column => column.Name)
        .Select(column => String.Format("[{0}]", column.Name))
        .ToList();
    }

    /// <summary>
    /// Returns a list of strings that can be used in the VALUES clause of an SQL Server INSERT statement.
    /// </summary>
    /// <example>
    /// Executing "String.Join("," + Environment.NewLine, columns.GetInsertValuesList())"
    /// on the AdventureWorks2012 Person.Person table will generate this string:
    /// <code>
    /// @AdditionalContactInfo,
    /// @BusinessEntityID,
    /// @Demographics,
    /// @EmailPromotion,
    /// @FirstName,
    /// @LastName,
    /// @MiddleName,
    /// @ModifiedDate,
    /// @NameStyle,
    /// @PersonType,
    /// @rowguid,
    /// @Suffix,
    /// @Title
    /// </code>
    /// </example>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetInsertValuesList()
    {
      return
        this
        .Where(column => !column.IsIdentity)
        .Where(column => column.CanBeUsedInInsertStatement)
        .OrderBy(column => column.Name)
        .Select(column => String.Format("{0}", column.SqlIdentifier))
        .ToList();
    }

    /// <summary>
    /// Returns a list of strings that can be used in the SET clause of an SQL Server UPDATE statement.
    /// </summary>
    /// <example>
    /// Executing "String.Join("," + Environment.NewLine, columns.GetUpdateColumnList())"
    /// on the AdventureWorks2012 Person.Person table will generate this string:
    /// <code>
    /// [AdditionalContactInfo] = @AdditionalContactInfo,
    /// [BusinessEntityID] = @BusinessEntityID,
    /// [Demographics] = @Demographics,
    /// [EmailPromotion] = @EmailPromotion,
    /// [FirstName] = @FirstName,
    /// [LastName] = @LastName,
    /// [MiddleName] = @MiddleName,
    /// [ModifiedDate] = @ModifiedDate,
    /// [NameStyle] = @NameStyle,
    /// [PersonType] = @PersonType,
    /// [rowguid] = @rowguid,
    /// [Suffix] = @Suffix,
    /// [Title] = @Title
    /// </code>
    /// </example>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetUpdateColumnList()
    {
      return
        this
        .Where(column => !column.IsIdentity)
        .Where(column => column.CanBeUsedInUpdateSetClause)
        .OrderBy(column => column.Name)
        .Select(column => String.Format("[{0}] = {1}", column.Name, column.SqlIdentifier))
        .ToList();
    }

    /// <summary>
    /// Returns a list of strings that can be used in the SET clause of an SQL Server UPDATE statement.
    /// </summary>
    /// <example>
    /// Executing "String.Join(Environment.NewLine + "AND ", table.Columns.GetWhereClauseColumnList("T"))"
    /// on the AdventureWorks2012 Person.Person table will generate this string:
    /// <code>
    /// T.[BusinessEntityID] = @BusinessEntityID
    /// AND T.[EmailPromotion] = @EmailPromotion
    /// AND T.[FirstName] = @FirstName
    /// AND T.[LastName] = @LastName
    /// AND T.[MiddleName] = @MiddleName
    /// AND T.[ModifiedDate] = @ModifiedDate
    /// AND T.[NameStyle] = @NameStyle
    /// AND T.[PersonType] = @PersonType
    /// AND T.[rowguid] = @rowguid
    /// AND T.[Suffix] = @Suffix
    /// AND T.[Title] = @Title;
    /// </code>
    /// </example>
    /// <param name="tableAlias">An optional string representing a table alias that will be prepended to each column name.</param>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetWhereClauseColumnList(String tableAlias = "")
    {
      return
        this
        .Where(column => column.CanBeUsedInSqlWhereClause)
        .OrderBy(column => column.Name)
        .Select(column => column.GetSqlWhereClause(tableAlias))
        .ToList();
    }

    /// <summary>
    /// Returns a list of strings that represent a set of class property declarations in the specified target language,
    /// one for each column.
    /// </summary>
    /// <example>
    /// Assuming the configuration's XmlSystem is set to Linq_XDocument, and TargetLanguage is set to CSharp,
    /// executing "String.Join(" { get; set; }" + Environment.NewLine + "    ", table.Columns.GetClassPropertyDeclarations("public")) + " { get; set; }""
    /// on the AdventureWorks2012 Person.Person table will generate this string:
    /// <code>
    /// public System.Int32 BusinessEntityID  /* primary key 1, foreign key */ { get; set; }
    /// public System.Xml.Linq.XElement AdditionalContactInfo { get; set; }
    /// public System.Xml.Linq.XElement Demographics { get; set; }
    /// public System.Int32 EmailPromotion { get; set; }
    /// public System.String FirstName { get; set; }
    /// public System.String LastName { get; set; }
    /// public System.String MiddleName { get; set; }
    /// public System.DateTime ModifiedDate { get; set; }
    /// public System.Boolean NameStyle { get; set; }
    /// public System.String PersonType { get; set; }
    /// public System.Guid rowguid { get; set; }
    /// public System.String Suffix { get; set; }
    /// public System.String Title { get; set; }
    /// </code>
    /// </example>
    /// <param name="scope">A target language keyword indicating the scope of the class property declarations. Can be blank.</param>
    /// <param name="includeKeyIdentificationComment">An enum value indicating whether or not to include
    /// a comment identifying the column as a primary and/or foreign key (see example code).</param>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetClassPropertyDeclarations(String scope, IncludeKeyIdentificationComment includeKeyIdentificationComment = IncludeKeyIdentificationComment.Yes)
    {
      return
        this
        .OrderByDescending(column => column.IsIdentity)
        .ThenByDescending(column => column.IsPrimaryKey)
        .ThenBy(column => column.PrimaryKeyOrdinal)
        .ThenByDescending(column => column.IsForeignKey)
        .Select(column => column.GetClassPropertyDeclaration(scope, includeKeyIdentificationComment))
        .ToList();
    }

    /// <summary>
    /// Returns a list of strings that represent a set of method parameter declarations in the specified target language,
    /// one for each column.
    /// </summary>
    /// <example>
    /// Assuming the configuration's XmlSystem is set to Linq_XDocument, and TargetLanguage is set to CSharp,
    /// executing "String.Join("," + Environment.NewLine, table.Columns.GetTargetLanguageMethodParameterNamesAndTypes())"
    /// on the AdventureWorks2012 Person.Person table will generate this string:
    /// <code>
    /// System.Int32 BusinessEntityID  /* primary key 1, foreign key */,
    /// System.Xml.Linq.XElement AdditionalContactInfo,
    /// System.Xml.Linq.XElement Demographics,
    /// System.Int32 EmailPromotion,
    /// System.String FirstName,
    /// System.String LastName,
    /// System.String MiddleName,
    /// System.DateTime ModifiedDate,
    /// System.Boolean NameStyle,
    /// System.String PersonType,
    /// System.Guid rowguid,
    /// System.String Suffix,
    /// System.String Title
    /// </code>
    /// </example>
    /// <param name="includeKeyIdentificationComment">An enum value indicating whether or not to include
    /// a comment identifying the column as a primary and/or foreign key (see example code).</param>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetTargetLanguageMethodIdentifiersAndTypes(IncludeKeyIdentificationComment includeKeyIdentificationComment = IncludeKeyIdentificationComment.Yes)
    {
      return
        this
        .OrderByDescending(column => column.IsIdentity)
        .ThenByDescending(column => column.IsPrimaryKey)
        .ThenBy(column => column.PrimaryKeyOrdinal)
        .ThenByDescending(column => column.IsForeignKey)
        .Select(column => column.GetTargetLanguageMethodParameterNameAndType(includeKeyIdentificationComment))
        .ToList();
    }

    /// <summary>
    /// Returns a list of strings that represent a set of SqlParameter constructor declarations in the specified target language,
    /// one for each column.
    /// </summary>
    /// <example>
    /// Assuming the configuration's XmlSystem is set to Linq_XDocument, and TargetLanguage is set to CSharp,
    /// executing ""command.Parameters.Add(" + String.Join(");" + Environment.NewLine + "command.Parameters.Add(", table.Columns.GetTargetLanguageSqlParameterText()) + ");""
    /// on the AdventureWorks2012 Person.Person table will generate this string:
    /// <code>
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@BusinessEntityID", SqlDbType = System.Data.SqlDbType.Int, Value = BusinessEntityID }  /* primary key 1, foreign key */);
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@AdditionalContactInfo", SqlDbType = System.Data.SqlDbType.Xml, Value = AdditionalContactInfo.GetSqlXml() });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@Demographics", SqlDbType = System.Data.SqlDbType.Xml, Value = Demographics.GetSqlXml() });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@EmailPromotion", SqlDbType = System.Data.SqlDbType.Int, Value = EmailPromotion });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@FirstName", SqlDbType = System.Data.SqlDbType.NVarChar, Value = FirstName });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@LastName", SqlDbType = System.Data.SqlDbType.NVarChar, Value = LastName });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@MiddleName", SqlDbType = System.Data.SqlDbType.NVarChar, Value = MiddleName });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@ModifiedDate", SqlDbType = System.Data.SqlDbType.DateTime, Value = ModifiedDate });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@NameStyle", SqlDbType = System.Data.SqlDbType.Bit, Value = NameStyle });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@PersonType", SqlDbType = System.Data.SqlDbType.NChar, Value = PersonType });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@rowguid", SqlDbType = System.Data.SqlDbType.UniqueIdentifier, Value = rowguid });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@Suffix", SqlDbType = System.Data.SqlDbType.NVarChar, Value = Suffix });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@Title", SqlDbType = System.Data.SqlDbType.NVarChar, Value = Title });
    /// </code>
    /// </example>
    /// <param name="includeKeyIdentificationComment">An enum value indicating whether or not to include
    /// a comment identifying the column as a primary and/or foreign key (see example code).</param>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetTargetLanguageSqlParameterText(IncludeKeyIdentificationComment includeKeyIdentificationComment = IncludeKeyIdentificationComment.Yes)
    {
      return
        this
        .OrderByDescending(column => column.IsIdentity)
        .ThenByDescending(column => column.IsPrimaryKey)
        .ThenBy(column => column.PrimaryKeyOrdinal)
        .ThenByDescending(column => column.IsForeignKey)
        .ThenBy(column => column.Name)
        .Select(column => column.GetTargetLanguageSqlParameterText(includeKeyIdentificationComment))
        .ToList();
    }
  }

  public class Column : SqlAbstractBase
  {
    /// <summary>
    /// The column's name as it appears on the database server.
    /// </summary>
    public String Name { get; set; }

    /// <summary>
    /// The position of this column in the list of columns in the parent table or view.
    /// </summary>
    public Int32 Ordinal { get; set; }

    /// <summary>
    /// The SQL Server native data type name (E.g. VARCHAR(50), INT, DATETIME, etc.), or aliased data type name (E.g. CustomerAddress, ZipCode, etc.).
    /// </summary>
    public String ServerDataTypeName { get; set; }

    /// <summary>
    /// The SQL Server native data type name.  If this column's <see cref="Utilities.Sql.Column.ServerDataTypeName">ServerDataTypeName</see> property
    /// is an aliased type name, this property will contain the underlying native data type name.  E.g. if this column has
    /// a ServerDataTypeName of "CustomerAddress", this property will contain the underlying native data type name of NVARCHAR(50).
    /// </summary>
    public String BaseServerDataTypeName { get; set; }

    /// <summary>
    /// The number of bytes the column occupies on the server.
    /// </summary>
    public Int32 PhysicalLength { get; set; }

    /// <summary>
    /// The same as <see cref="Utilities.Sql.Column.PhysicalLength">PhysicalLength</see>, unless the column's type
    /// is something like VARBINARY(MAX), N/VARCHAR(MAX) or XML.
    /// </summary>
    public Int32 LogicalLength { get; set; }

    public Int32 Precision { get; set; }
    public Int32 Scale { get; set; }
    public Boolean IsNullable { get; set; }
    public Boolean IsIdentity { get; set; }
    public Boolean IsXmlDocument { get; set; }
    public String XmlCollectionName { get; set; }
    public Boolean IsPrimaryKey { get; set; }
    
    /// <summary>
    /// Some primary keys consist of multiple columns.  If <see cref="Utilities.Sql.Column.IsPrimaryKey">IsPrimaryKey</see> is true, this property
    /// indicates this column's position in the set of columns that make up the primary key.
    /// </summary>
    public Int32 PrimaryKeyOrdinal { get; set; }
    public Boolean IsForeignKey { get; set; }

    /// <summary>
    /// If <see cref="Utilities.Sql.Column.IsForeignKey">IsForeignKey</see> is true, the name of the table this foreign key references.
    /// </summary>
    public String PrimaryKeyTable { get; set; }

    /// <summary>
    /// If <see cref="Utilities.Sql.Column.IsForeignKey">IsForeignKey</see> is true, the name of the column this foreign key references.
    /// </summary>
    public String PrimaryKeyColumn { get; set; }

    private String _clrTypeName = null;
    /// <summary>
    /// The fully qualified CLR type name for this column's <see cref="Utilities.Sql.Column.BaseServerDataTypeName">BaseServerDataTypeName</see>.
    /// E.g. this property would contain System.String for a column type of NVARCHAR(50).
    /// </summary>
    public String ClrTypeName
    {
      get
      {
        if (this._clrTypeName == null)
          this._clrTypeName = this.GetClrTypeNameFromNativeSqlType();

        return this._clrTypeName;
      }
    }

    private String _sqlDbTypeEnumName = null;
    public String SqlDbTypeEnumName
    {
      get
      {
        if (this._sqlDbTypeEnumName == null)
          this._sqlDbTypeEnumName = this.GetSqlDbTypeFromNativeSqlType();

        return this._sqlDbTypeEnumName;
      }
    }

    private String _targetLanguageIdentifier = null;
    /// <summary>
    /// This column's name, converted to a valid identifier in the target language.
    /// </summary>
    public String TargetLanguageIdentifier
    {
      get
      {
        if (this._targetLanguageIdentifier == null)
          this._targetLanguageIdentifier = this.GetTargetLanguageIdentifier(this.Name);

        return this._targetLanguageIdentifier;
      }
    }

    private String _sqlIdentifier = null;
    /// <summary>
    /// This column's name, converted to a valid identifier for use in TSQL.
    /// </summary>
    public String SqlIdentifier
    {
      get
      {
        if (this._sqlIdentifier == null)
          this._sqlIdentifier = "@" + this.Name.Replace(" ", "_");

        return this._sqlIdentifier;
      }
    }

    private String _sqlIdentifierTypeAndSize = null;
    /// <summary>
    /// This column's SQL Server data type name and size (if applicable).  E.g. VARCHAR(10), INT, DECIMAL(18, 5), etc.
    /// </summary>
    public String SqlIdentifierTypeAndSize
    {
      get
      {
        if (this._sqlIdentifierTypeAndSize == null)
          this._sqlIdentifierTypeAndSize = this.GetSqlParameterTypeAndSize();

        return this._sqlIdentifierTypeAndSize;
      }
    }

    private Nullable<Boolean> _isTrimmable = null;
    /// <summary>
    /// Can this column be trimmed (i.e. is this column's underlying type a string)?
    /// </summary>
    public Boolean IsTrimmable
    {
      get
      {
        if (!this._isTrimmable.HasValue)
          this._isTrimmable = this.IsDataTypeTrimmable();

        return this._isTrimmable.Value;
      }
    }

    private String _sqlExpressionToConvertToString = null;
    /// <summary>
    /// The TSQL expression to convert this column to an NVARCHAR(MAX).
    /// </summary>
    public String SqlExpressionToConvertToString
    {
      get
      {
        if (this._sqlExpressionToConvertToString == null)
          this._sqlExpressionToConvertToString = this.GetSqlExpressionToConvertToString();

        return this._sqlExpressionToConvertToString;
      }
    }

    private String _targetLanguageSqlParameterValue = null;
    /// <summary>
    /// Target language expression to assign this column to the Value property of an <see cref="System.Data.SqlClient.SqlParameter">SqlParameter</see> instance.
    /// </summary>
    public String TargetLanguageSqlParameterValue
    {
      get
      {
        if (this._targetLanguageSqlParameterValue == null)
          this._targetLanguageSqlParameterValue = this.GetTargetLanguageSqlParameterValue();

        return this._targetLanguageSqlParameterValue;
      }
    }

    public XmlNodeType XmlNodeType
    {
      get
      {
        return (this.IsXmlDocument ? XmlNodeType.Document : XmlNodeType.DocumentFragment);
      }
    }

    public Boolean CanBeUsedInSqlWhereClause
    {
      get { return this.BaseServerDataTypeName != "XML"; }
    }

    private String _keyIdentificationComment = null;
    /// <summary>
    /// It can be helpful to annotate the generated code of primary and foreign key columns with a comment, simply because of their importance.
    /// <para>This property contains such a comment for this column.  For primary keys, the comment will contain the text "primary key"
    /// followed by a number indicating the column's position within a multipart key.  For foreign keys, the comment simply contains
    /// the text "foreign key".  For columns that are both a primary and foreign key, the comment will contain both kinds of text.</para>
    /// </summary>
    public String KeyIdentificationComment
    {
      get
      {
        if (this._keyIdentificationComment == null)
          this._keyIdentificationComment = this.GetKeyIdentificationComment();

        return this._keyIdentificationComment;
      }
    }

    public Boolean CanBeUsedInUpdateSetClause
    {
      get { return (this.BaseServerDataTypeName != "TIMESTAMP") && !this.IsIdentity; }
    }

    public Boolean CanBeUsedInInsertStatement
    {
      get { return (this.BaseServerDataTypeName != "TIMESTAMP") && !this.IsIdentity; }
    }

    public Column(Configuration configuration)
      : base(configuration)
    {
    }

    /// <summary>
    /// An expression that compares this column's Name property with its SqlIdentifier property.
    /// <para>This expression is valid TSQL and can be used in a WHERE clause.</para>
    /// </summary>
    /// <param name="tableAlias">An optional string representing a table alias that will be prepended to the column name.</param>
    /// <returns>A String</returns>
    public String GetSqlWhereClause(String tableAlias = "")
    {
      String format = "";

      switch (this.BaseServerDataTypeName)
      {
        case "GEOGRAPHY":
        case "GEOMETRY":
          format = "({0}[{1}].STEquals({2}) = 1)";
          break;
        case "HIERARCHYID":
        case "IMAGE":
          format = "CAST({0}[{1}] AS VARBINARY(MAX)) = CAST({2} AS VARBINARY(MAX))";
          break;
        case "NTEXT":
        case "TEXT":
          format = "CAST({0}[{1}] AS NVARCHAR(MAX)) = CAST({2} AS NVARCHAR(MAX))";
          break;
        default:
          format = "{0}[{1}] = {2}";
          break;
      }

      return String.Format(format, (String.IsNullOrWhiteSpace(tableAlias) ? "" : tableAlias + "."), this.Name, this.SqlIdentifier);
    }

    private String GetClrTypeNameFromNativeSqlType()
    {
      Func<String, String> getAppropriateClrType =
        clrType =>
        {
          switch (this._configuration.TargetLanguage)
          {
            case TargetLanguage.CSharp:
            case TargetLanguage.FSharp:
              return this.IsNullable ? "System.Nullable<System." + clrType + ">" : "System." + clrType;
            case TargetLanguage.VisualBasic:
              return this.IsNullable ? "System.Nullable(Of System." + clrType + ")" : "System." + clrType;
            default:
              throw new NotImplementedException(String.Format(Properties.Resources.UnknownTargetLanguageValue, this._configuration.TargetLanguage));
          }
        };

      switch (this.BaseServerDataTypeName)
      {
        case "BIGINT":
          return getAppropriateClrType("Int64");
        case "BINARY":
        case "FILESTREAM":
        case "IMAGE":
        case "ROWVERSION":
        case "TIMESTAMP":
        case "VARBINARY":
          switch (this._configuration.TargetLanguage)
          {
            case TargetLanguage.CSharp:
            case TargetLanguage.FSharp:
              return "System.Byte[]";
            case TargetLanguage.VisualBasic:
              return "System.Byte()";
            default:
              throw new NotImplementedException(String.Format(Properties.Resources.UnknownTargetLanguageValue, this._configuration.TargetLanguage));
          }
        case "BIT":
          return getAppropriateClrType("Boolean");
        case "CURSOR":
          return "";
        case "DATE":
        case "DATETIME":
        case "DATETIME2":
        case "SMALLDATETIME":
          return getAppropriateClrType("DateTime");
        case "DATETIMEOFFSET":
          return getAppropriateClrType("DateTimeOffset");
        case "DECIMAL":
        case "MONEY":
        case "NUMERIC":
        case "SMALLMONEY":
          return getAppropriateClrType("Decimal");
        case "FLOAT":
          return getAppropriateClrType("Double");
        case "GEOGRAPHY":
          return "Microsoft.SqlServer.Types.SqlGeography";
        case "GEOMETRY":
          return "Microsoft.SqlServer.Types.SqlGeometry";
        case "HIERARCHYID":
          return "Microsoft.SqlServer.Types.SqlHierarchyId";
        case "INT":
          return getAppropriateClrType("Int32");
        case "CHAR":
        case "NCHAR":
        case "NTEXT":
        case "NVARCHAR":
        case "TEXT":
        case "VARCHAR":
          return "System.String";
        case "XML":
          switch (this._configuration.XmlSystem)
          {
            case XmlSystem.AsString:
              return "System.String";
            case XmlSystem.Linq_XDocument:
              if (this.IsXmlDocument)
                return "System.Xml.Linq.XDocument";
              else
                return "System.Xml.Linq.XElement";
            case XmlSystem.NonLinq_XmlDocument:
              return "System.Xml.XmlDocument";
            default:
              return String.Format("ERROR - Don't know how to handle '{0}'.", this._configuration.XmlSystem);
          }
        case "REAL":
          return getAppropriateClrType("Single");
        case "SMALLINT":
          return getAppropriateClrType("Int16");
        case "SQL_VARIANT":
          return "System.Object";
        case "TIME":
          return getAppropriateClrType("TimeSpan");
        case "TINYINT":
          return getAppropriateClrType("Byte");
        case "UNIQUEIDENTIFIER":
          return getAppropriateClrType("Guid");
        default:
          return String.Format("ERROR - Can't find CLR type that corresponds to SQL Server type {0}.", this.BaseServerDataTypeName);
      }
    }

    /// <summary>
    /// Given the name of an SqlDataReader instance, return an expression that can be used
    /// to safely get the column's value out of the reader.
    /// </summary>
    /// <param name="readerName">The name of an SqlDataReader instance.</param>
    /// <returns>A String.</returns>
    public String GetTargetLanguageDataReaderExpression(String readerName)
    {
      switch (this._configuration.TargetLanguage)
      {
        case TargetLanguage.CSharp:
        case TargetLanguage.FSharp:
          return String.Format("{0}.GetValueOrDefault<{1}>(\"{2}\")", readerName, this.ClrTypeName, this.Name);
        case TargetLanguage.VisualBasic:
          return String.Format("{0}.GetValueOrDefault(Of {1})(\"{2}\")", readerName, this.ClrTypeName, this.Name);
        default:
          throw new NotImplementedException(String.Format(Properties.Resources.UnknownTargetLanguageValue, this._configuration.TargetLanguage));
      }
    }

    private String GetSqlDbTypeFromNativeSqlType()
    {
      var result = "";

      /* Some of this code may look redundant, but the case of the returned
         string is important. This is because the text returned by this function
         will be used to generate source code, probably for a case-sensitive language
         like C#. */

      switch (this.BaseServerDataTypeName.ToUpper())
      {
        case "BIGINT":
          result = "BigInt";
          break;
        case "BINARY":
        case "FILESTREAM":
        case "VARBINARY":
          result = "VarBinary";
          break;
        case "ROWVERSION":
        case "TIMESTAMP":
          result = "Timestamp";
          break;
        case "BIT":
          result = "Bit";
          break;
        case "GEOGRAPHY":
        case "GEOMETRY":
        case "HIERARCHYID":
          result = "Udt";
          break;
        case "DATE":
          result = "Date";
          break;
        case "DATETIME":
        case "SMALLDATETIME":
          result = "DateTime";
          break;
        case "DATETIME2":
          result = "DateTime2";
          break;
        case "DATETIMEOFFSET":
          result = "DateTimeOffset";
          break;
        case "DECIMAL":
        case "NUMERIC":
          result = "Decimal";
          break;
        case "MONEY":
          result = "Money";
          break;
        case "SMALLMONEY":
          result = "SmallMoney";
          break;
        case "FLOAT":
          result = "Float";
          break;
        case "IMAGE":
          result = "Binary";
          break;
        case "INT":
          result = "Int";
          break;
        case "CHAR":
          result = "Char";
          break;
        case "NCHAR":
          result = "NChar";
          break;
        case "NTEXT":
          result = "NText";
          break;
        case "NVARCHAR":
          result = "NVarChar";
          break;
        case "TEXT":
          result = "Text";
          break;
        case "VARCHAR":
          result = "VarChar";
          break;
        case "XML":
          result = "Xml";
          break;
        case "REAL":
          result = "Real";
          break;
        case "SMALLINT":
          result = "SmallInt";
          break;
        case "SQL_VARIANT":
          result = "Variant";
          break;
        case "TIME":
          result = "Time";
          break;
        case "TINYINT":
          result = "TinyInt";
          break;
        case "UNIQUEIDENTIFIER":
          result = "UniqueIdentifier";
          break;
        default:
          result = "";
          break;
      }

      if (!String.IsNullOrWhiteSpace(result))
        return "System.Data.SqlDbType." + result;
      else
        return "";
    }

    private String GetSqlParameterTypeAndSize()
    {
      switch (this.ServerDataTypeName)
      {
        case "DATETIME2":
        case "DATETIMEOFFSET":
        case "TIME":
          return String.Format("{0}({1})", this.ServerDataTypeName, this.Scale);

        case "DECIMAL":
        case "NUMERIC":
          return String.Format("{0}({1}, {2})", this.ServerDataTypeName, this.Precision, this.Scale);

        case "VARBINARY":
        case "VARCHAR":
        case "NVARCHAR":
          return String.Format("{0}({1})", this.ServerDataTypeName, (this.LogicalLength == -1 ? "MAX" : this.LogicalLength.ToString()));

        case "BINARY":
        case "CHAR":
        case "NCHAR":
          return String.Format("{0}({1})", this.ServerDataTypeName, this.LogicalLength);

        case "XML":
          if (String.IsNullOrWhiteSpace(this.XmlCollectionName))
            return this.ServerDataTypeName;
          else
            return String.Format("{0}({1}, {2})", this.ServerDataTypeName, this.IsXmlDocument ? "DOCUMENT" : "CONTENT", this.XmlCollectionName);

        default:
          return this.ServerDataTypeName;
      }
    }

    private Boolean IsDataTypeTrimmable()
    {
      return "CHAR/VARCHAR/NCHAR/NVARCHAR/TEXT/NTEXT".Contains(this.BaseServerDataTypeName);
    }

    private String GetSqlExpressionToConvertToString()
    {
      switch (this.BaseServerDataTypeName)
      {
        case "CHAR":
        case "NCHAR":
        case "NVARCHAR":
        case "SYSNAME":
        case "TIMESTAMP":
        case "VARCHAR":
          return this.SqlIdentifier;

        case "BIGINT":
        case "BIT":
        case "DATE":
        case "DATETIME2":
        case "DATETIMEOFFSET":
        case "DECIMAL":
        case "FLOAT":
        case "INT":
        case "MONEY":
        case "NTEXT":
        case "NUMERIC":
        case "REAL":
        case "SMALLINT":
        case "SMALLMONEY":
        case "TEXT":
        case "TINYINT":
        case "UNIQUEIDENTIFIER":
        case "XML":
          return String.Format("CONVERT(NVARCHAR(MAX), {0})", this.SqlIdentifier);

        case "DATETIME":
        case "SMALLDATETIME":
          return String.Format("CONVERT(NVARCHAR(MAX), {0}, 121)", this.SqlIdentifier);

        case "TIME":
          return String.Format("CONVERT(NVARCHAR(MAX), {0}, 14)", this.SqlIdentifier);

        case "GEOGRAPHY":
        case "GEOMETRY":
          return String.Format("{0}.STAsText()", this.SqlIdentifier);

        case "HIERARCHYID":
          return String.Format("{0}.ToString()", this.SqlIdentifier);

        case "BINARY":
        case "IMAGE":
        case "VARBINARY":
          return String.Format("'{0} with length ' + CONVERT(NVARCHAR(MAX), DATALENGTH({1})) + '.'", this.BaseServerDataTypeName, this.SqlIdentifier);

        case "SQL_VARIANT":
          return String.Format("dbo.util_Get_SqlVariant_As_String({0})", this.SqlIdentifier);

        default:
          return String.Format("Don't know how to convert type {0} to a string.", this.BaseServerDataTypeName);
      }
    }

    /// <summary>
    /// Returns a string that can be used in generated code to create a new SqlParameter instance for this column.
    /// </summary>
    /// <param name="includeKeyIdentificationComment">An enum value indicating whether or not to include
    /// a comment identifying the column as a primary and/or foreign key.</param>
    /// <returns>A String.</returns>
    public String GetTargetLanguageSqlParameterText(IncludeKeyIdentificationComment includeKeyIdentificationComment = IncludeKeyIdentificationComment.Yes)
    {
      var comment = ((includeKeyIdentificationComment == IncludeKeyIdentificationComment.Yes) ? this.KeyIdentificationComment : "");

      switch (this._configuration.TargetLanguage)
      {
        case TargetLanguage.CSharp:
          if (this.SqlDbTypeEnumName == "System.Data.SqlDbType.Udt")
            return String.Format("new SqlParameter() {{ ParameterName = \"{0}\", SqlDbType = {1}, UdtTypeName = \"{2}\", Value = {3} }}{4}",
              this.SqlIdentifier, this.SqlDbTypeEnumName, this.BaseServerDataTypeName, this.TargetLanguageSqlParameterValue, comment);
          else
            return String.Format("new SqlParameter() {{ ParameterName = \"{0}\", SqlDbType = {1}, Value = {2} }}{3}",
              this.SqlIdentifier, this.SqlDbTypeEnumName, this.TargetLanguageSqlParameterValue, comment);
        case TargetLanguage.FSharp:
          if (this.SqlDbTypeEnumName == "System.Data.SqlDbType.Udt")
            return String.Format("new SqlParameter(ParameterName = \"{0}\", SqlDbType = {1}, UdtTypeName = \"{2}\", Value = {3}){4}",
              this.SqlIdentifier, this.SqlDbTypeEnumName, this.BaseServerDataTypeName, this.TargetLanguageSqlParameterValue, comment);
          else
            return String.Format("new SqlParameter(ParameterName = \"{0}\", SqlDbType = {1}, Value = {2}){3}",
              this.SqlIdentifier, this.SqlDbTypeEnumName, this.TargetLanguageSqlParameterValue, comment);
        case TargetLanguage.VisualBasic:
          if (this.SqlDbTypeEnumName == "System.Data.SqlDbType.Udt")
            return String.Format("new SqlParameter() With {{ .ParameterName = \"{0}\", .SqlDbType = {1}, .UdtTypeName = \"{2}\", .Value = {3} }}{4}",
              this.SqlIdentifier, this.SqlDbTypeEnumName, this.BaseServerDataTypeName, this.TargetLanguageSqlParameterValue, comment);
          else
            return String.Format("new SqlParameter() With {{ .ParameterName = \"{0}\", .SqlDbType = {1}, .Value = {2} }}{3}",
              this.SqlIdentifier, this.SqlDbTypeEnumName, this.TargetLanguageSqlParameterValue, comment);
        default:
          throw new NotImplementedException(String.Format(Properties.Resources.UnknownTargetLanguageValue, this._configuration.TargetLanguage));
      }
    }

    private String GetTargetLanguageSqlParameterValue()
    {
      if (this.ServerDataTypeName == "XML")
        switch (this._configuration.XmlSystem)
        {
          case XmlSystem.AsString:
          case XmlSystem.Linq_XDocument:
            return String.Format("{0}.GetSqlXml()", this.TargetLanguageIdentifier);
          case XmlSystem.NonLinq_XmlDocument:
            return String.Format("{0}.GetSqlXml(XmlNodeType.{1})", this.TargetLanguageIdentifier, this.XmlNodeType);
          default:
            return String.Format(Properties.Resources.UnknownXmlSystemValue, this._configuration.XmlSystem);
        }
      else
        return this.TargetLanguageIdentifier;
    }

    private String GetKeyIdentificationComment()
    {
      var comments = new List<String>();

      if (this.IsIdentity)
        comments.Add("identity");

      if (this.IsPrimaryKey)
        comments.Add(String.Format("primary key {0}", this.PrimaryKeyOrdinal));

      if (this.IsForeignKey)
        comments.Add("foreign key");

      var format = "";

      switch (this._configuration.TargetLanguage)
      {
        case TargetLanguage.CSharp:
          format = "  /* {0} */";
          break;
        case TargetLanguage.FSharp:
          format = "  (* {0} *)";
          break;
        case TargetLanguage.VisualBasic:
          format = "  ' {0}";
          break;
        default:
          throw new NotImplementedException(String.Format(Properties.Resources.UnknownTargetLanguageValue, this._configuration.TargetLanguage));
      }

      return (comments.Count == 0) ? "" : String.Format(format, String.Join(", ", comments));
    }

    /// <summary>
    /// Return a string that can be used in generated code to represent this column as a target language method parameter.
    /// </summary>
    /// <param name="includeKeyIdentificationComment">An enum value indicating whether or not to include
    /// a comment identifying the column as a primary and/or foreign key.</param>
    /// <returns>A String.</returns>
    public String GetTargetLanguageMethodParameterNameAndType(IncludeKeyIdentificationComment includeKeyIdentificationComment = IncludeKeyIdentificationComment.Yes)
    {
      var format = "";

      switch (this._configuration.TargetLanguage)
      {
        case TargetLanguage.CSharp:
          format = "{0} {1}{2}";
          break;
        case TargetLanguage.FSharp:
          format = "({1} : {0}{2})";
          break;
        case TargetLanguage.VisualBasic:
          format = "{1} As {0}{2}";
          break;
        default:
          throw new NotImplementedException(String.Format(Properties.Resources.UnknownTargetLanguageValue, this._configuration.TargetLanguage));
      }

      return String.Format(format, this.ClrTypeName, this.TargetLanguageIdentifier,
        ((includeKeyIdentificationComment == IncludeKeyIdentificationComment.Yes) ? this.KeyIdentificationComment : ""));
    }

    /// <summary>
    /// Return a string that can be used in generated code to represent this column as a target language class property declaration.
    /// </summary>
    /// <param name="scope"></param>
    /// <param name="includeKeyIdentificationComment">An enum value indicating whether or not to include
    /// a comment identifying the column as a primary and/or foreign key.</param>
    /// <returns>A String.</returns>
    public String GetClassPropertyDeclaration(String scope, IncludeKeyIdentificationComment includeKeyIdentificationComment = IncludeKeyIdentificationComment.Yes)
    {
      var format = "";

      switch (this._configuration.TargetLanguage)
      {
        case TargetLanguage.CSharp:
          format = "{0} {1} {2}{3}";
          break;
        case TargetLanguage.FSharp:
          format = "member val {0} {2} = Unchecked.defaultof<{1}> with get, set{3}";
          break;
        case TargetLanguage.VisualBasic:
          format = "{0} Property {2}() As {1}{3}";
          break;
        default:
          throw new NotImplementedException(String.Format(Properties.Resources.UnknownTargetLanguageValue, this._configuration.TargetLanguage));
      }

      return String.Format(format, scope, this.ClrTypeName, this.TargetLanguageIdentifier,
        ((includeKeyIdentificationComment == IncludeKeyIdentificationComment.Yes) ? this.KeyIdentificationComment : ""));
    }

    /// <summary>
    /// Return a string that can be used in generated code to represent this column as a TSQL stored procedure parameter.
    /// </summary>
    /// <param name="includeKeyIdentificationComment">An enum value indicating whether or not to include
    /// a comment identifying the column as a primary and/or foreign key.</param>
    /// <returns>A String.</returns>
    public String GetStoredProcedureParameterDeclaration(IncludeKeyIdentificationComment includeKeyIdentificationComment = IncludeKeyIdentificationComment.Yes)
    {
      return String.Format("{0} {1}{2}", this.SqlIdentifier, this.SqlIdentifierTypeAndSize,
        ((includeKeyIdentificationComment == IncludeKeyIdentificationComment.Yes) ? this.KeyIdentificationComment : ""));
    }
  }
}
