/* See UNLICENSE.txt file for license details. */

using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Linq;
using System.Xml;

using Utilities.Core;

namespace Utilities.Sql
{
  /// <summary>
  /// Some of the methods in the classes in this namespace select a set of columns.
  /// This enumeration allows for selecting a subset of a table's columns
  /// based on the column's key type.
  /// <para>These values used to be separate properties in the Column object,
  /// but it turned out to be more flexible to package them all in an
  /// enumeration.</para>
  /// </summary>
  [Flags]
  public enum ColumnType
  {
    /// <summary>
    /// A column should never have this value.  However, this value is useful as
    /// a starting point when building a ColumnType for a particular column.
    /// </summary>
    Unknown = 0,

    /// <summary>
    /// A column that is not a primary or a foreign key, nor an ID column.
    /// </summary>
    NonKeyAndNonID = 1,

    /// <summary>
    /// A primary key column.
    /// </summary>
    PrimaryKey = 2,

    /// <summary>
    /// A foreign key column.
    /// </summary>
    ForeignKey = 4,

    /// <summary>
    /// An identity column.
    /// </summary>
    ID = 8,

    /// <summary>
    /// Columns with the XML type cannot be used in a WHERE clause.
    /// </summary>
    CanAppearInSqlWhereClause = 16,

    /// <summary>
    /// Columns with the TIMESTAMP type and ID columns cannot appear in an UPDATE statement's SET clause.
    /// </summary>
    CanAppearInUpdateSetClause = 32,

    /// <summary>
    /// Columns with the TIMESTAMP type and ID columns cannot appear in an INSERT statement.
    /// </summary>
    CanAppearInInsertStatement = 64,

    /// <summary>
    /// Combination of CanAppearInInsertStatement and CanAppearInUpdateSetClause.
    /// </summary>
    CanAppearInMergeSelectList = CanAppearInUpdateSetClause | CanAppearInInsertStatement,

    /// <summary>
    /// All column types.
    /// </summary>
    All = NonKeyAndNonID | PrimaryKey | ForeignKey | ID | CanAppearInSqlWhereClause | CanAppearInUpdateSetClause | CanAppearInInsertStatement | CanAppearInMergeSelectList
  }

  /// <summary>
  /// The text generated by some of the <see cref="Utilities.Sql.Column">Column</see> class's properties can include
  /// a comment indicating whether or not that column is a primary or foreign key.
  /// This enumeration is used to turn that capability on or off.
  /// </summary>
  public enum IncludeKeyIdentificationComment { No, Yes }

  /// <summary>
  /// .Net languages can handle an SQL Server column of type 'xml' in three ways:
  /// as a <see cref="System.String">String</see>, as an <see cref="System.Xml.XmlDocument">XmlDocument</see>,
  /// or as an <see cref="System.Xml.Linq.XDocument">XDocument</see>.
  /// </summary>
  public enum XmlSystem
  {
    /// <summary>
    /// Create code to treat the xml column as a <see cref="System.String">String</see>.
    /// </summary>
    AsString,

    /// <summary>
    /// Create code to treat the xml column as an <see cref="System.Xml.XmlDocument">XmlDocument</see>.
    /// </summary>
    NonLinq_XmlDocument,

    /// <summary>
    /// Create code to treat the xml column as an <see cref="System.Xml.Linq.XDocument">XDocument</see>.
    /// </summary>
    Linq_XDocument
  }

  /// <summary>
  /// XML database columns can optionally have associated XSDs stored in the server that the column can be validated against.
  /// If an XSD is assigned to the XML column, SQL Server will automatically do this validation when an INSERT or UPDATE is done.
  /// <para>But it would be nice to be able to perform this validation on the client before sending the XML to the server.</para>
  /// <para>A value from this enumeration is passed to the Configuration object and allows you to
  /// choose if and where you want client-side XML validation code to be generated.</para>
  /// </summary>
  [Flags]
  public enum XmlValidationLocation
  {
    /// <summary>
    /// No XML validation code will be generated.
    /// </summary>
    None = 0,

    /// <summary>
    /// If the XML column has an associated XSD, XML validation code will be inserted into the property setter generated by the Column.GetClassPropertyDeclaration method.
    /// </summary>
    PropertySetter = 1,

    /// <summary>
    /// If the XML column has an associated XSD, XML validation will be performed when the XML value is assigned to an SqlParameter's Value property.
    /// </summary>
    SqlParameterValueAssignment = 2,

    /// <summary>
    /// If the XML column has an associated XSD, XML validation will be performed in both the property setter and when assigning the XML to an SqlParameter's Value property.
    /// </summary>
    Both = PropertySetter | SqlParameterValueAssignment
  }

  /// <summary>
  /// The three currently supported target languages are C#, F# and VB.
  /// <para>TSQL is always supported, so there's no need for a separate TSQL value in this enumeration.</para>
  /// <para>The languages are broken out by version number.  This is to allow for flexibility in generating things
  /// like properties, where the later versions of a language support auto properties, but the earlier versions do not.</para>
  /// <para>See <a href="http://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29#Versions">C# (Programming Language)</a> for a complete table of C# version numbers.</para>
  /// <para>See <a href="http://en.wikipedia.org/wiki/Visual_Basic_.NET">Visual Basic.Net</a> for a list of VB.Net version numbers.</para>
  /// </summary>
  public enum TargetLanguage
  {
    /// <summary>
    /// .Net 1.0, Visual Studio 2002.
    /// </summary>
    CSharp_1_0,

    /// <summary>
    /// .Net 1.1, Visual Studio 2003.  And yes, it really is C# 1.2, not C# 1.1.
    /// </summary>
    CSharp_1_2,

    /// <summary>
    /// .Net 2.0, Visual Studio 2005.
    /// </summary>
    CSharp_2_0,

    /// <summary>
    /// .Net 3.0, Visual Studio 2008.
    /// </summary>
    CSharp_3_0,

    /// <summary>
    /// .Net 4.0, Visual Studio 2010.
    /// </summary>
    CSharp_4_0,

    /// <summary>
    /// .Net 4.5, Visual Studio 2012 and .Net 4.5.1, 2013.
    /// </summary>
    CSharp_5_0,

    /// <summary>
    /// Convenience value equal to the latest version of C#.
    /// </summary>
    CSharp_Latest = CSharp_5_0,


    /// <summary>
    /// .Net 4.0, Visual Studio 2010.
    /// </summary>
    FSharp_2_0,

    /// <summary>
    /// .Net 4.5, Visual Studio 2012.
    /// </summary>
    FSharp_3_0,

    /// <summary>
    /// .Net 4.5.1, Visual Studio 2013.
    /// </summary>
    FSharp_3_1,

    /// <summary>
    /// Convenience value equal to the latest version of F#.
    /// </summary>
    FSharp_Latest = FSharp_3_1,


    /// <summary>
    /// .Net 1.0, Visual Studio 2002.
    /// </summary>
    VisualBasic_7_0,

    /// <summary>
    /// .Net 1.1, Visual Studio 2003.
    /// </summary>
    VisualBasic_7_1,

    /// <summary>
    /// .Net 2.0, Visual Studio 2005.
    /// </summary>
    VisualBasic_8_0,

    /// <summary>
    /// .Net 3.0, Visual Studio 2008.
    /// </summary>
    VisualBasic_9_0,

    /// <summary>
    /// .Net 4.0, Visual Studio 2010.
    /// </summary>
    VisualBasic_10_0,

    /// <summary>
    /// .Net 4.5, Visual Studio 2012.
    /// </summary>
    VisualBasic_11_0,

    /// <summary>
    /// .Net 4.5.1, Visual Studio 2013. (Just a version number bump - no new language features).
    /// </summary>
    VisualBasic_12_0,

    /// <summary>
    /// Convenience value equal to the latest version of VB.Net.
    /// </summary>
    VisualBasic_Latest = VisualBasic_12_0
  }

  /// <summary>
  /// System.Enum types can't have methods directly attached to them, so extension methods are a necessary workaround.
  /// </summary>
  public static class TargetLanguageExtensionMethods
  {
    /// <summary>
    /// Not all versions of a target language support auto properties.  C# 3.0 and later, F# 3.0 and later, and VB.Net 10.0 and later do.
    /// </summary>
    public static Boolean DoesSupportAutoProperties(this TargetLanguage targetLanguage)
    {
      return
        ((targetLanguage >= TargetLanguage.CSharp_3_0) && (targetLanguage <= TargetLanguage.CSharp_Latest)) ||
        ((targetLanguage >= TargetLanguage.FSharp_3_0) && (targetLanguage <= TargetLanguage.FSharp_Latest)) ||
        ((targetLanguage >= TargetLanguage.VisualBasic_10_0) && (targetLanguage <= TargetLanguage.VisualBasic_Latest));
    }

    public static Boolean IsCSharp(this TargetLanguage targetLanguage)
    {
      return (targetLanguage >= TargetLanguage.CSharp_1_0) && (targetLanguage <= TargetLanguage.CSharp_Latest);
    }

    public static Boolean IsFSharp(this TargetLanguage targetLanguage)
    {
      return (targetLanguage >= TargetLanguage.FSharp_2_0) && (targetLanguage <= TargetLanguage.FSharp_Latest);
    }

    public static Boolean IsVisualBasic(this TargetLanguage targetLanguage)
    {
      return (targetLanguage >= TargetLanguage.VisualBasic_7_0) && (targetLanguage <= TargetLanguage.VisualBasic_Latest);
    }
  }

  public enum IsTargetLanguageCaseSensitive { No, Yes }

  /// <summary>
  /// An instance of this class is passed into the <see cref="Utilities.Sql.Server">Server</see> constructor.
  /// </summary>
  public class Configuration
  {
    /// <summary>
    /// A valid <see cref="System.Data.SqlClient.SqlConnection">SqlConnection</see>.
    /// <para>The connection must be open before being passed to the <see cref="Utilities.Sql.Server">Server</see> constructor.</para>
    /// </summary>
    public SqlConnection Connection { get; set; }

    /// <summary>
    /// Specify what kind of CLR datatype (String, XmlDocument, or XDocument) should be used to handle
    /// SQL Server columns of type 'xml'.
    /// </summary>
    public XmlSystem XmlSystem { get; set; }

    /// <summary>
    /// If and where any XML validation code should be generated.
    /// </summary>
    public XmlValidationLocation XmlValidationLocation { get; set; }

    /// <summary>
    /// If your code only calls methods that return TSQL code, then this setting has no affect.
    /// </summary>
    public TargetLanguage TargetLanguage { get; set; }

    public IsTargetLanguageCaseSensitive IsTargetLanguageCaseSensitive { get; set; }
  }

  public static class IdentifierHelper
  {
    private static List<String> _csharpKeywords =
      new List<String>()
      {
        /* Keywords. */
        "abstract",
        "as",
        "base",
        "bool",
        "break",
        "byte",
        "case",
        "catch",
        "char",
        "checked",
        "class",
        "cons",
        "continue",
        "decimal",
        "default",
        "delegate",
        "do",
        "double",
        "else",
        "enum",
        "event",
        "explicit",
        "extern",
        "false",
        "finally",
        "fixed",
        "float",
        "for",
        "foreach",
        "goto",
        "if",
        "implicit",
        "in",
        "int",
        "interface",
        "internal",
        "is",
        "lock",
        "long",
        "namespace",
        "new",
        "null",
        "object",
        "operator",
        "out",
        "override",
        "params",
        "private",
        "protected",
        "public",
        "readonly",
        "ref",
        "return",
        "sbyte",
        "sealed",
        "short",
        "sizeof",
        "stackalloc",
        "static",
        "string",
        "struct",
        "switch",
        "this",
        "throw",
        "true",
        "try",
        "typeof",
        "uint",
        "ulong",
        "unchecked",
        "unsafe",
        "ushort",
        "using",
        "virtual",
        "void",
        "volatile",
        "while",

        /* Contextual keywords and reserved words. */
        "alias",
        "ascending",
        "by",
        "const",
        "descending",
        "equals",
        "field",
        "from",
        "get",
        "group",
        "into",
        "join",
        "let",
        "method",
        "on",
        "orderby",
        "param",
        "partial",
        "property",
        "select",
        "set",
        "type",
        "var",
        "where",
        "yield",

        /* Not formally listed in the language spec as keywords
           or reserved words, but should be treated as such anyways. */
        "async",
        "await"
      };

    private static List<String> _fsharpKeywords =
      new List<String>()
      {
        /* Keywords. */
        "abstract",
        "and",
        "as",
        "assert",
        "base",
        "begin",
        "class",
        "default",
        "delegate",
        "do",
        "done",
        "downcast",
        "downto",
        "elif",
        "else",
        "end",
        "exception",
        "extern",
        "false",
        "finally",
        "for",
        "fun",
        "function",
        "global",
        "if",
        "in",
        "inherit",
        "inline",
        "interface",
        "internal",
        "lazy",
        "let",
        "match",
        "member",
        "module",
        "mutable",
        "namespace",
        "new",
        "null",
        "of",
        "open",
        "or",
        "override",
        "private",
        "public",
        "rec",
        "return",
        "sig",
        "static",
        "struct",
        "then",
        "to",
        "true",
        "try",
        "type",
        "upcast",
        "use",
        "val",
        "void",
        "when",
        "while",
        "with",
        "yield",

        /* Reserved words. */
        "atomic",
        "break",
        "checked",
        "component",
        "const",
        "constraint",
        "constructor",
        "continue",
        "eager",
        "fixed",
        "fori",
        "functor",
        "include",
        "measure",
        "method",
        "mixin",
        "object",
        "parallel",
        "params",
        "process",
        "protected",
        "pure",
        "recursive",
        "sealed",
        "tailcall",
        "trait",
        "virtual",
        "volatile"
      };

    private static List<String> _visualBasicKeywords =
      new List<String>()
      {
        /* Keywords. */
        "AddHandler",
        "AddressOf",
        "Alias",
        "And",        "AndAlso",
        "As",
        "Boolean",
        "ByRef",        "Byte",
        "ByVal",
        "Call",
        "Case",        "Catch",
        "CBool",
        "CByte",
        "CChar",        "CDate",
        "CDbl",
        "CDec",
        "Char",        "CInt",
        "Class",
        "CLng",
        "CObj",        "Const",
        "Continue",
        "CSByte",
        "CShort",        "CSng",
        "CStr",
        "CType",
        "CUInt",        "CULng",
        "CUShort",
        "Date",
        "Decimal",        "Declare",
        "Default",
        "Delegate",
        "Dim",        "DirectCast",
        "Do",
        "Double",
        "Each",        "Else",
        "ElseIf",
        "End",
        "EndIf",        "Enum",
        "Erase",
        "Error",
        "Event",        "Exit",
        "False",
        "Finally",
        "For",        "Friend",
        "Function",
        "Get",
        "GetType",        "GetXmlNamespace",
        "Global",
        "GoSub",
        "GoTo",        "Handles",
        "If",
        "Implements",
        "Imports",        "In",
        "Inherits",
        "Integer",
        "Interface",        "Is",
        "IsNot",
        "Let",
        "Lib",        "Like",
        "Long",
        "Loop",
        "Me",        "Mod",
        "Module",
        "MustInherit",
        "MustOverride",        "MyBase",
        "MyClass",
        "Namespace",
        "Narrowing",        "New",
        "Next",
        "Not",
        "Nothing",        "NotInheritable",
        "NotOverridable",
        "Object",
        "Of",        "On",
        "Operator",
        "Option",
        "Optional",        "Or",
        "OrElse",
        "Overloads",
        "Overridable",        "Overrides",
        "ParamArray",
        "Partial",
        "Private",        "Property",
        "Protected",
        "Public",
        "RaiseEvent",        "ReadOnly",
        "ReDim",
        "REM",
        "RemoveHandler",        "Resume",
        "Return",
        "SByte",
        "Select",        "Set",
        "Shadows",
        "Shared",
        "Short",        "Single",
        "Static",
        "Step",
        "Stop",        "String",
        "Structure",
        "Sub",
        "SyncLock",        "Then",
        "Throw",
        "To",
        "True",        "Try",
        "TryCast",
        "TypeOf",
        "UInteger",        "ULong",
        "UShort",
        "Using",
        "Variant",        "Wend",
        "When",
        "While",
        "Widening",        "With",
        "WithEvents",
        "WriteOnly",
        "Xor",
        /* Sometimes treated like keywords, but not really keywords. */
        "Aggregate",
        "AM",
        "Ansi",
        "Async",
        "Auto",
        "Await",
        "Binary",
        "By",
        "Compare",
        "Custom",
        "Distinct",
        "Equals",
        "From",
        "Group",
        "Infer",
        "Into",
        "IsFalse",
        "IsTrue",
        "Iterator",
        "Join",
        "Let",
        "Mid",
        "Off",
        "Order",
        "Out",
        "PM",
        "Preserve",
        "Select",
        "Skip",
        "Strict",
        "Take",
        "Text",
        "Unicode",
        "Until",
        "Where"
      };

    private static List<String> _targetLanguageKeywords;
    private static Configuration _configuration;

    public static void Init(Configuration configuration)
    {
      _configuration = configuration;

      if (configuration.TargetLanguage.IsCSharp())
        _targetLanguageKeywords = _csharpKeywords;
      else if (configuration.TargetLanguage.IsFSharp())
        _targetLanguageKeywords = _fsharpKeywords;
      else if (configuration.TargetLanguage.IsVisualBasic())
        _targetLanguageKeywords = _visualBasicKeywords;
      else
        throw new NotImplementedException(String.Format(Properties.Resources.UnknownTargetLanguageValue, configuration.TargetLanguage));
    }

    /// <summary>
    /// Convert an SQL identifier, like a database name or column name, into a valid
    /// identifier for the target language (C#, F#, etc.) that was set in
    /// the configuration.
    /// <para>System.dll has code providers for both C# (Microsoft.CSharp.CSharpCodeProvider) and
    /// Visual Basic (Microsoft.VisualBasic.VBCodeProvider).  Why not use code from those classes
    /// to determine if a given string is a valid identifier?</para>
    /// <para>There are several reasons.  One is that .Net does not provide a corresponding F# code provider.
    /// The second reason is that the code providers' CreateValidIdentifier() method
    /// is written in a very naive way.  CreateValidIdentifier("42 is the answer!") returns "42 is the answer!", which is laughably wrong.
    /// A third reason is that the code providers' IsValidIdentifier() doesn't recognize all of the keywords/reserved words I think it should, like all of the
    /// LINQ keywords, and new keywords like C#'s async and await. (I understand these aren't really keywords, but they certainly shouldn't
    /// be treated as valid identifiers).</para>
    /// <para>The result of these drawbacks is this method, coupled with a lengthy list of keywords, reserved words, and
    /// any other words that shouldn't be used as identifiers in C#, VB, or F#.</para>
    /// </summary>
    /// <param name="sqlIdentifier"></param>
    /// <returns></returns>
    public static String GetTargetLanguageIdentifier(String sqlIdentifier)
    {
      var result = sqlIdentifier.Replace(" ", "_").Replace(".", "_");

      if (Char.IsDigit(result[0]))
        result = "_" + result;

      var stringComparison =
        (_configuration.IsTargetLanguageCaseSensitive == IsTargetLanguageCaseSensitive.Yes)
          ? StringComparison.CurrentCulture
          : StringComparison.CurrentCultureIgnoreCase;

      if (_targetLanguageKeywords.Exists(keyword => String.Equals(keyword, result, stringComparison)))
        result = "_" + result;

      return result;
    }
  }

  /// <summary>
  /// Server and its related classes allow T4 templates to
  /// use SQL Server metadata to easily generate database access code.
  /// <para>The class hierarchy is quite simple:  A Server contains zero or more Schemas,
  /// a schema contains zero or more Databases,
  /// a Database contains zero or more Tables, and a Table contains one or more Columns.
  /// (The Table class is used for both tables and views.  They're differentiated by the Table.IsView property.)</para>
  /// <para>For more examples, see the https://github.com/ctimmons/t4_sql_examples solution.</para>
  /// <example>
  /// To create a Server instance, create a connection and open it.  Then create a Configuration
  /// instance and pass it to the Server constructor.
  /// <code>
  /// using (var connection = new SqlConnection("Data Source=laptop2;Initial Catalog=AdventureWorks2012;Integrated Security=true;"))
  /// {
  ///   connection.Open();
  ///    
  ///   var configuration =
  ///     new Configuration()
  ///     {
  ///       Connection = connection,
  ///       XmlSystem = XmlSystem.Linq_XDocument,
  ///       TargetLanguage = TargetLanguage.CSharp,
  ///       IsTargetLanguageCaseSensitive = IsTargetLanguageCaseSensitive.Yes
  ///     };
  /// 
  ///   var server = new Server(configuration);
  ///  
  ///   // Code that uses the server instance here...
  /// }
  /// </code>
  /// </example>
  /// <example>
  /// Once a Server instance is created, it can be used to retrieve metadata for the databases,
  /// tables, and columns on that server.
  /// <code>
  /// // Find a specific table in a database:
  /// var personTable =
  ///   server
  ///   .Databases
  ///   .Where(db => db.Name.EqualsCI("AdventureWorks2012"))
  ///   .Schemas
  ///   .Where(db => db.Name.EqualsCI("Person"))
  ///   .Tables
  ///   .Where(db => db.Name.EqualsCI("Person"))
  ///   .First();
  ///   
  /// // Get a ready-made list of target language method parameter declarations
  /// // for use in an update method:
  /// var parameterDeclarations = personTable.Columns.GetTargetLanguageMethodIdentifiersAndTypes(ColumnType.CanAppearInUpdateSetClause));
  /// </code>
  /// </example>
  /// </summary>
  public class Server
  {
    public Configuration Configuration { get; private set; }

    private List<Database> _databases = null;
    public List<Database> Databases
    {
      get
      {
        if (this._databases == null)
        {
          this._databases = new List<Database>();
          var table = this.Configuration.Connection.GetSchema("Databases");
          foreach (DataRow row in table.Rows)
            this._databases.Add(new Database(this, row["database_name"].ToString()));
        }

        return this._databases;
      }
    }

    public Server(Configuration configuration)
      : base()
    {
      IdentifierHelper.Init(configuration);
      this.Configuration = configuration;
    }
  }

  public class Database
  {
    public Server Server { get; private set; }

    /// <summary>
    /// The database name as it appears on the database server.
    /// </summary>
    public String Name { get; private set; }

    private List<Schema> _schemas = null;
    public List<Schema> Schemas
    {
      get
      {
        if (this._schemas == null)
        {
          this.Server.Configuration.Connection.ExecuteUnderDatabaseInvariant(this.Name,
            () =>
              {
                this._schemas = new List<Schema>();
                var sql = @"
SELECT
    [SCHEMA_NAME] = S.[name]
  FROM
    sys.schemas AS S
    INNER JOIN sys.database_principals AS U ON U.principal_id = S.principal_id
  WHERE
    U.is_fixed_role = 0
    AND U.sid IS NOT NULL
    AND DATALENGTH(U.sid) > 0
    AND LOWER(S.[Name]) NOT IN ('sys', 'guest');";

                var schemas = this.Server.Configuration.Connection.GetDataSet(sql).Tables[0];
                foreach (DataRow row in schemas.Rows)
                  this._schemas.Add(new Schema(this, row["SCHEMA_NAME"].ToString()));
              });
        }

        return this._schemas;
      }
    }

    public Database(Server server, String name)
      : base()
    {
      this.Server = server;
      this.Name = name;
    }
  }

  public class Schema
  {
    public Database Database { get; private set; }

    /// <summary>
    /// The schema name as it appears on the database server.
    /// </summary>
    public String Name { get; private set; }

    private List<Table> _tables = null;
    public List<Table> Tables
    {
      get
      {
        if (this._tables == null)
        {
          this.Database.Server.Configuration.Connection.ExecuteUnderDatabaseInvariant(this.Database.Name,
            () =>
            {
              this._tables = new List<Table>();
              var table = this.Database.Server.Configuration.Connection.GetSchema("Tables");
              foreach (DataRow row in table.Rows)
              {
                if (this.Name.EqualsCI(row["table_schema"].ToString()))
                {
                  this._tables.Add(new Table(this, row["table_name"].ToString(), row["table_type"].ToString().EqualsCI("VIEW")));
                }
              }
            });
        }

        return this._tables;
      }
    }

    public Schema(Database database, String name)
      : base()
    {
      this.Database = database;
      this.Name = name;
    }
  }

  public class Table
  {
    public Schema Schema { get; private set; }

    /// <summary>
    /// The table name as it appears on the database server.
    /// </summary>
    public String Name { get; private set; }

    /// <summary>
    /// This class is named Table, but it handles both tables and views.  This property indicates what a Table instance really contains.
    /// </summary>
    public Boolean IsView { get; private set; }

    /// <summary>
    /// In SQL Server 2005 and later, a table name in a database is not necessarily unique,
    /// because the same table name can be used in different schemas.
    /// <para>This property produces a unique table identifier by combining the schema name
    /// and table name.  The two components are also rendered safe by wrapping them in 
    /// square brackets.  This makes it useful when generating TSQL code.</para>
    /// </summary>
    public String SchemaNameAndTableName
    {
      get { return String.Format("[{0}].[{1}]", this.Schema.Name, this.Name); }
    }

    private String _targetLanguageTableIdentifier = null;
    /// <summary>
    /// The table name converted for use as a valid identifier in generated target language code.
    /// </summary>
    public String TargetLanguageTableIdentifier
    {
      get
      {
        if (this._targetLanguageTableIdentifier == null)
          this._targetLanguageTableIdentifier = IdentifierHelper.GetTargetLanguageIdentifier(this.Schema.Name + "_" + this.Name);

        return this._targetLanguageTableIdentifier;
      }
    }

    private Columns _columns = null;
    public Columns Columns
    {
      get
      {
        if (this._columns == null)
          this.Schema.Database.Server.Configuration.Connection.ExecuteUnderDatabaseInvariant(this.Schema.Database.Name, () => this._columns = new Columns(this));

        return this._columns;
      }
    }

    public Table(Schema schema, String name, Boolean isView)
      : base()
    {
      this.Schema = schema;
      this.Name = name;
      this.IsView = isView;
    }
  }

  public class Columns : List<Column>
  {
    public Columns(Table table)
      : base()
    {
      var sql = @"
;WITH foreign_keys_CTE (FOREIGN_KEY_TABLE, FOREIGN_KEY_COLUMN, PRIMARY_KEY_SCHEMA, PRIMARY_KEY_TABLE, PRIMARY_KEY_COLUMN)
AS
(
  SELECT
      FOREIGN_KEY_TABLE = OBJECT_NAME(FKC.parent_object_id),
      FOREIGN_KEY_COLUMN = C.NAME,
      PRIMARY_KEY_SCHEMA = OBJECT_SCHEMA_NAME(FKC.referenced_object_id),
      PRIMARY_KEY_TABLE = OBJECT_NAME(FKC.referenced_object_id),
      PRIMARY_KEY_COLUMN = CREF.NAME
    FROM
      sys.foreign_key_columns AS FKC
      INNER JOIN sys.columns AS C ON FKC.parent_column_id = C.column_id AND FKC.parent_object_id = c.object_id
      INNER JOIN sys.columns AS CREF ON FKC.referenced_column_id = CREF.column_id AND FKC.referenced_object_id = cref.object_id
),
primary_keys_CTE (OBJECT_ID, COLUMN_ID, PRIMARY_KEY_ORDINAL, PRIMARY_KEY_DIRECTION)
AS
(
  SELECT
      i.object_id,
      c.column_id,
      ic.key_ordinal,
      CASE
        WHEN ic.is_descending_key = 0 THEN 'ASC'
        ELSE 'DESC'
      END
    FROM
      sys.indexes AS i
      INNER JOIN sys.index_columns AS ic ON i.object_id = ic.object_id AND i.index_id = ic.index_id and i.is_primary_key = 1
      INNER JOIN sys.columns AS C ON C.[object_id] = IC.[object_id] AND c.[column_id] = ic.column_id
),
column_type_CTE (USER_TYPE_ID, SERVER_DATATYPE_NAME, NATIVE_SERVER_DATATYPE_NAME)
AS
(
  SELECT
      T1.user_type_id,
      SERVER_DATATYPE_NAME = UPPER(T1.name),
      NATIVE_SERVER_DATATYPE_NAME = UPPER(COALESCE(T2.name, T1.name))
    FROM
      sys.types AS T1
      LEFT OUTER JOIN sys.types AS T2 ON T2.user_type_id = T1.system_type_id AND T1.is_table_type = 0
)
SELECT
  DISTINCT
    S.schema_id,
    [SCHEMA_NAME] = S.[name],
    TABLE_NAME = TBL.name,
    COLUMN_NAME = C.[name],
    COLUMN_ORDINAL = C.column_id - 1,
    C.user_type_id,
    C.system_type_id,
    SERVER_DATATYPE_NAME = CT_CTE.SERVER_DATATYPE_NAME,
    NATIVE_SERVER_DATATYPE_NAME = CT_CTE.NATIVE_SERVER_DATATYPE_NAME,
    PHYSICAL_LENGTH = C.max_length,
    LOGICAL_LENGTH = 
      CASE
        WHEN ((CT_CTE.SERVER_DATATYPE_NAME = 'NCHAR') OR (CT_CTE.SERVER_DATATYPE_NAME = 'NVARCHAR')) AND (C.max_length > -1) THEN
          C.max_length / 2
        ELSE
          C.max_length
      END,
    C.[precision],
    C.scale,
    IS_NULLABLE = CASE C.is_nullable WHEN 0 THEN 'N' ELSE 'Y' END,
    IS_IDENTITY = CASE C.is_identity WHEN 0 THEN 'N' ELSE 'Y' END,
    IS_XML_DOCUMENT = CASE C.is_xml_document WHEN 0 THEN 'N' ELSE 'Y' END,
    XML_COLLECTION_NAME = COALESCE(XMLCOLL.name, ''),
    IS_PRIMARY_KEY = CASE WHEN (PK_CTE.primary_key_ordinal IS NULL) THEN 'N' ELSE 'Y' END,
    PRIMARY_KEY_ORDINAL = COALESCE(PK_CTE.primary_key_ordinal, -1),
    PRIMARY_KEY_DIRECTION = COALESCE(PK_CTE.PRIMARY_KEY_DIRECTION, ''),
    IS_FOREIGN_KEY = CASE WHEN (FKCTE.foreign_key_table IS NULL) THEN 'N' ELSE 'Y' END,
    PRIMARY_KEY_SCHEMA = COALESCE(FKCTE.primary_key_schema, ''),
    PRIMARY_KEY_TABLE = COALESCE(FKCTE.primary_key_table, ''),
    PRIMARY_KEY_COLUMN = COALESCE(FKCTE.primary_key_column, '')
  FROM
    sys.schemas AS S
    INNER JOIN sys.{0} AS TBL ON TBL.schema_id = S.schema_id
    INNER JOIN sys.columns AS C ON TBL.[object_id] = C.[object_id]
    LEFT OUTER JOIN sys.xml_schema_collections AS XMLCOLL ON XMLCOLL.xml_collection_id = C.xml_collection_id
    LEFT OUTER JOIN foreign_keys_CTE AS FKCTE ON (FKCTE.foreign_key_table = TBL.[name]) AND (FKCTE.foreign_key_column = C.[name])
    LEFT OUTER JOIN primary_keys_CTE AS PK_CTE ON PK_CTE.object_id = TBL.object_id AND PK_CTE.column_id = C.column_id
    LEFT OUTER JOIN column_type_CTE AS CT_CTE ON CT_CTE.USER_TYPE_ID = C.user_type_id
  WHERE
    S.[schema_id] = SCHEMA_ID('{1}')
    AND TBL.[name] = '{2}';";

      var select = String.Format(sql, (table.IsView ? "views" : "tables"), table.Schema.Name, table.Name);

      foreach (DataRow row in table.Schema.Database.Server.Configuration.Connection.GetDataSet(select).Tables[0].Rows)
      {
        var columnType = ColumnType.Unknown;

        if (row["IS_IDENTITY"].ToString().ToUpper() == "Y")
          columnType |= ColumnType.ID;

        if (row["IS_PRIMARY_KEY"].ToString().ToUpper() == "Y")
          columnType |= ColumnType.PrimaryKey;

        if (row["IS_FOREIGN_KEY"].ToString().ToUpper() == "Y")
          columnType |= ColumnType.ForeignKey;

        if (columnType == ColumnType.Unknown)
          columnType |= ColumnType.NonKeyAndNonID;

        var nativeServerDataTypeName = row["NATIVE_SERVER_DATATYPE_NAME"].ToString();

        if ((nativeServerDataTypeName != "TIMESTAMP") && !columnType.HasFlag(ColumnType.ID))
          columnType |= (ColumnType.CanAppearInInsertStatement | ColumnType.CanAppearInUpdateSetClause);

        if (nativeServerDataTypeName != "XML")
          columnType |= ColumnType.CanAppearInSqlWhereClause;

        this.Add(
          new Column(table)
          {
            Name = row["COLUMN_NAME"].ToString(),
            Ordinal = Convert.ToInt32(row["COLUMN_ORDINAL"]),
            ColumnType = columnType,
            ServerDataTypeName = row["SERVER_DATATYPE_NAME"].ToString(),
            NativeServerDataTypeName = nativeServerDataTypeName,
            PhysicalLength = Convert.ToInt32(row["PHYSICAL_LENGTH"]),
            LogicalLength = Convert.ToInt32(row["LOGICAL_LENGTH"]),
            Precision = Convert.ToInt32(row["PRECISION"]),
            Scale = Convert.ToInt32(row["SCALE"]),
            IsNullable = row["IS_NULLABLE"].ToString().ToUpper() == "Y",
            IsXmlDocument = row["IS_XML_DOCUMENT"].ToString().ToUpper() == "Y",
            XmlCollectionName = row["XML_COLLECTION_NAME"].ToString(),
            PrimaryKeyOrdinal = Convert.ToInt32(row["PRIMARY_KEY_ORDINAL"]),
            PrimaryKeyDirection = row["PRIMARY_KEY_DIRECTION"].ToString(),
            PrimaryKeySchema = row["PRIMARY_KEY_SCHEMA"].ToString(),
            PrimaryKeyTable = row["PRIMARY_KEY_TABLE"].ToString(),
            PrimaryKeyColumn = row["PRIMARY_KEY_COLUMN"].ToString()
          });
      }
    }

    public List<String> GetCreateTableColumnDeclarations()
    {
      return
        this
        .OrderByDescending(column => column.ColumnType.HasFlag(ColumnType.ID))
        .ThenByDescending(column => column.ColumnType.HasFlag(ColumnType.PrimaryKey))
        .ThenBy(column => column.PrimaryKeyOrdinal)
        .Select(column => column.GetCreateTableColumnDeclaration())
        .ToList();
    }

    /// <summary>
    /// Return a list of strings that can be used as a parameter declarations in a stored procedure.
    /// <para>Primary and foreign key columns may optionally be documented with a comment.</para>
    /// </summary>
    /// <example>
    /// Executing "String.Join("," + Environment.NewLine, columns.GetStoredProcedureParameters())"
    /// on the AdventureWorks2012 Person.Person table will generate this string:
    /// <code>
    /// @BusinessEntityID INT  /* primary key 1, foreign key */,
    /// @AdditionalContactInfo XML(CONTENT, AdditionalContactInfoSchemaCollection),
    /// @Demographics XML(CONTENT, IndividualSurveySchemaCollection),
    /// @EmailPromotion INT,
    /// @FirstName NAME,
    /// @LastName NAME,
    /// @MiddleName NAME,
    /// @ModifiedDate DATETIME,
    /// @NameStyle NAMESTYLE,
    /// @PersonType NCHAR(2),
    /// @rowguid UNIQUEIDENTIFIER,
    /// @Suffix NVARCHAR(10),
    /// @Title NVARCHAR(8)
    /// </code>
    /// </example>
    /// <param name="columnType">An enum value indicating what kind of column type(s) to include in the return value.</param>
    /// <param name="includeKeyIdentificationComment">An enum value indicating whether or not to include
    /// a comment identifying the column as a primary and/or foreign key (see example code).</param>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetStoredProcedureParameters(ColumnType columnType, IncludeKeyIdentificationComment includeKeyIdentificationComment = IncludeKeyIdentificationComment.Yes)
    {
      return
        this
        .Where(column => (column.ColumnType & columnType) > 0)
        .OrderByDescending(column => column.ColumnType.HasFlag(ColumnType.ID))
        .ThenByDescending(column => column.ColumnType.HasFlag(ColumnType.PrimaryKey))
        .ThenBy(column => column.PrimaryKeyOrdinal)
        .Select(column => column.GetStoredProcedureParameterDeclaration(includeKeyIdentificationComment))
        .ToList();
    }

    /// <summary>
    /// Return a list of strings which contain primary key column names, along with their direction -
    /// ASC for ascending, or DESC for descending.
    /// </summary>
    /// <example>
    /// Executing "String.Join("," + Environment.NewLine, columns.GetTSQLPrimaryKeyColumns())"
    /// on the AdventureWorks2012 [HumanResources].[EmployeeDepartmentHistory] table will generate this string:
    /// <code>
    /// [BusinessEntityID] ASC,
    /// [DepartmentID] ASC,
    /// [ShiftID] ASC,
    /// [StartDate] ASC
    /// </code>
    /// </example>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetTSQLPrimaryKeyColumns()
    {
      return
        this
        .Where(column => column.ColumnType.HasFlag(ColumnType.PrimaryKey))
        .OrderBy(column => column.PrimaryKeyOrdinal)
        .Select(column => String.Format("[{0}] {1}", column.Name, column.PrimaryKeyDirection))
        .ToList();
    }

    /// <summary>
    /// Returns a list of strings that can be used in the SELECT clause of an SQL Server SELECT statement.
    /// </summary>
    /// <example>
    /// Executing "String.Join("," + Environment.NewLine, columns.GetSelectColumnList("T"))"
    /// on the AdventureWorks2012 Person.Person table will generate this string:
    /// <code>
    /// T.[AdditionalContactInfo],
    /// T.[BusinessEntityID],
    /// T.[Demographics],
    /// T.[EmailPromotion],
    /// T.[FirstName],
    /// T.[LastName],
    /// T.[MiddleName],
    /// T.[ModifiedDate],
    /// T.[NameStyle],
    /// T.[PersonType],
    /// T.[rowguid],
    /// T.[Suffix],
    /// T.[Title]
    /// </code>
    /// </example>
    /// <param name="tableAlias">An optional string representing a table alias that will be prepended to each column name.</param>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetSelectColumnList(String tableAlias = "")
    {
      return
        this
        .OrderBy(column => column.Name)
        .Select(column => String.Format("{0}[{1}]", (String.IsNullOrWhiteSpace(tableAlias) ? "" : tableAlias + "."), column.Name))
        .ToList();
    }

    private IEnumerable<Column> GetOrderedListBasedOnColumnType(ColumnType columnType)
    {
      return
        this
        .Where(column => (column.ColumnType & columnType) > 0)
        .OrderBy(column => column.Name);
    }

    /// <summary>
    /// Returns a list of strings that can be used in the SELECT statement of a MERGE statement's CTE USING clause.
    /// </summary>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetMergeSelectList()
    {
      return
        this
        .GetOrderedListBasedOnColumnType(ColumnType.CanAppearInMergeSelectList)
        .Select(column => String.Format("[{0}] = {1}", column.Name, column.SqlIdentifier))
        .ToList();
    }

    /// <summary>
    /// Returns a list of strings that can be used in column matching logic of a MERGE statement's CTE USING clause.
    /// </summary>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetMergeTargetAndSourceMatchingExpressions()
    {
      return
        this
        .Where(column => column.ColumnType.HasFlag(ColumnType.PrimaryKey))
        .OrderBy(column => column.PrimaryKeyOrdinal)
        .Select(column => String.Format("Target.[{0}] = Source.[{0}]", column.Name))
        .ToList();
    }

    /// <summary>
    /// Returns a list of strings that can be used in the UPDATE statement of a MERGE statement.
    /// </summary>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetMergeUpdateColumnList()
    {
      return
        this
        .GetOrderedListBasedOnColumnType(ColumnType.CanAppearInUpdateSetClause)
        .Select(column => String.Format("[{0}] = Source.[{0}]", column.Name))
        .ToList();
    }

    /// <summary>
    /// Returns a list of strings that can be used in the INSERT statement's VALUE clause of a MERGE statement.
    /// </summary>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetMergeInsertValueList()
    {
      return
        this
        .GetOrderedListBasedOnColumnType(ColumnType.CanAppearInInsertStatement)
        .Select(column => String.Format("Source.[{0}]", column.Name))
        .ToList();
    }

    /// <summary>
    /// Returns a list of strings that can be used in the column list of an SQL Server INSERT statement.
    /// </summary>
    /// <example>
    /// Executing "String.Join("," + Environment.NewLine, columns.GetInsertColumnList())"
    /// on the AdventureWorks2012 Person.Person table will generate this string:
    /// <code>
    /// [AdditionalContactInfo],
    /// [BusinessEntityID],
    /// [Demographics],
    /// [EmailPromotion],
    /// [FirstName],
    /// [LastName],
    /// [MiddleName],
    /// [ModifiedDate],
    /// [NameStyle],
    /// [PersonType],
    /// [rowguid],
    /// [Suffix],
    /// [Title]
    /// </code>
    /// </example>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetInsertColumnList()
    {
      return
        this
        .GetOrderedListBasedOnColumnType(ColumnType.CanAppearInInsertStatement)
        .Select(column => String.Format("[{0}]", column.Name))
        .ToList();
    }

    /// <summary>
    /// Returns a list of strings that can be used in the VALUES clause of an SQL Server INSERT statement.
    /// </summary>
    /// <example>
    /// Executing "String.Join("," + Environment.NewLine, columns.GetInsertValuesList())"
    /// on the AdventureWorks2012 Person.Person table will generate this string:
    /// <code>
    /// @AdditionalContactInfo,
    /// @BusinessEntityID,
    /// @Demographics,
    /// @EmailPromotion,
    /// @FirstName,
    /// @LastName,
    /// @MiddleName,
    /// @ModifiedDate,
    /// @NameStyle,
    /// @PersonType,
    /// @rowguid,
    /// @Suffix,
    /// @Title
    /// </code>
    /// </example>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetInsertValuesList()
    {
      return
        this
        .GetOrderedListBasedOnColumnType(ColumnType.CanAppearInInsertStatement)
        .Select(column => String.Format("{0}", column.SqlIdentifier))
        .ToList();
    }

    /// <summary>
    /// Returns a list of strings that can be used in the SET clause of an SQL Server UPDATE statement.
    /// </summary>
    /// <example>
    /// Executing "String.Join("," + Environment.NewLine, columns.GetUpdateColumnList())"
    /// on the AdventureWorks2012 Person.Person table will generate this string:
    /// <code>
    /// [AdditionalContactInfo] = @AdditionalContactInfo,
    /// [BusinessEntityID] = @BusinessEntityID,
    /// [Demographics] = @Demographics,
    /// [EmailPromotion] = @EmailPromotion,
    /// [FirstName] = @FirstName,
    /// [LastName] = @LastName,
    /// [MiddleName] = @MiddleName,
    /// [ModifiedDate] = @ModifiedDate,
    /// [NameStyle] = @NameStyle,
    /// [PersonType] = @PersonType,
    /// [rowguid] = @rowguid,
    /// [Suffix] = @Suffix,
    /// [Title] = @Title
    /// </code>
    /// </example>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetUpdateColumnList()
    {
      return
        this
        .GetOrderedListBasedOnColumnType(ColumnType.CanAppearInUpdateSetClause)
        .Select(column => String.Format("[{0}] = {1}", column.Name, column.SqlIdentifier))
        .ToList();
    }

    /// <summary>
    /// Returns a list of strings that can be used in the SET clause of an SQL Server UPDATE statement.
    /// </summary>
    /// <example>
    /// Executing "String.Join(Environment.NewLine + "AND ", table.Columns.GetWhereClauseColumnList("T"))"
    /// on the AdventureWorks2012 Person.Person table will generate this string:
    /// <code>
    /// T.[BusinessEntityID] = @BusinessEntityID
    /// AND T.[EmailPromotion] = @EmailPromotion
    /// AND T.[FirstName] = @FirstName
    /// AND T.[LastName] = @LastName
    /// AND T.[MiddleName] = @MiddleName
    /// AND T.[ModifiedDate] = @ModifiedDate
    /// AND T.[NameStyle] = @NameStyle
    /// AND T.[PersonType] = @PersonType
    /// AND T.[rowguid] = @rowguid
    /// AND T.[Suffix] = @Suffix
    /// AND T.[Title] = @Title;
    /// </code>
    /// </example>
    /// <param name="columnType">An enum value indicating what kind of column type(s) to include in the return value.</param>
    /// <param name="tableAlias">An optional string representing a table alias that will be prepended to each column name.</param>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetWhereClauseColumnList(ColumnType columnType, String tableAlias = "")
    {
      return
        this
        .Where(column => column.ColumnType.HasFlag(ColumnType.CanAppearInSqlWhereClause))
        .Where(column => (column.ColumnType & columnType) > 0)
        .OrderBy(column => column.Name)
        .Select(column => column.GetSqlWhereClause(tableAlias))
        .ToList();
    }

    /// <summary>
    /// Returns a list of strings that represent a set of class property declarations in the specified target language,
    /// one for each column.
    /// </summary>
    /// <example>
    /// Assuming the configuration's XmlSystem is set to Linq_XDocument, and TargetLanguage is set to CSharp,
    /// executing "String.Join(" { get; set; }" + Environment.NewLine + "    ", table.Columns.GetClassPropertyDeclarations("public")) + " { get; set; }""
    /// on the AdventureWorks2012 Person.Person table will generate this string:
    /// <code>
    /// public System.Int32 BusinessEntityID  /* primary key 1, foreign key */ { get; set; }
    /// public System.Xml.Linq.XElement AdditionalContactInfo { get; set; }
    /// public System.Xml.Linq.XElement Demographics { get; set; }
    /// public System.Int32 EmailPromotion { get; set; }
    /// public System.String FirstName { get; set; }
    /// public System.String LastName { get; set; }
    /// public System.String MiddleName { get; set; }
    /// public System.DateTime ModifiedDate { get; set; }
    /// public System.Boolean NameStyle { get; set; }
    /// public System.String PersonType { get; set; }
    /// public System.Guid rowguid { get; set; }
    /// public System.String Suffix { get; set; }
    /// public System.String Title { get; set; }
    /// </code>
    /// </example>
    /// <param name="scope">A target language keyword indicating the scope of the class property declarations. Can be blank.</param>
    /// <param name="includeKeyIdentificationComment">An enum value indicating whether or not to include
    /// a comment identifying the column as a primary and/or foreign key (see example code).</param>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetClassPropertyDeclarations(String scope, IncludeKeyIdentificationComment includeKeyIdentificationComment = IncludeKeyIdentificationComment.Yes)
    {
      return
        this
        .OrderByDescending(column => column.ColumnType.HasFlag(ColumnType.ID))
        .ThenByDescending(column => column.ColumnType.HasFlag(ColumnType.PrimaryKey))
        .ThenBy(column => column.PrimaryKeyOrdinal)
        .ThenByDescending(column => column.ColumnType.HasFlag(ColumnType.ForeignKey))
        .Select(column => column.GetTargetLanguageProperty(scope, includeKeyIdentificationComment))
        .ToList();
    }

    /// <summary>
    /// Returns a list of strings that represent a set of method parameter declarations in the specified target language,
    /// one for each column.
    /// </summary>
    /// <example>
    /// Assuming the configuration's XmlSystem is set to Linq_XDocument, and TargetLanguage is set to CSharp,
    /// executing "String.Join("," + Environment.NewLine, table.Columns.GetTargetLanguageMethodParameterNamesAndTypes())"
    /// on the AdventureWorks2012 Person.Person table will generate this string:
    /// <code>
    /// System.Int32 BusinessEntityID  /* primary key 1, foreign key */,
    /// System.Xml.Linq.XElement AdditionalContactInfo,
    /// System.Xml.Linq.XElement Demographics,
    /// System.Int32 EmailPromotion,
    /// System.String FirstName,
    /// System.String LastName,
    /// System.String MiddleName,
    /// System.DateTime ModifiedDate,
    /// System.Boolean NameStyle,
    /// System.String PersonType,
    /// System.Guid rowguid,
    /// System.String Suffix,
    /// System.String Title
    /// </code>
    /// </example>
    /// <param name="columnType">An enum value indicating what kind of column type(s) to include in the return value.</param>
    /// <param name="includeKeyIdentificationComment">An enum value indicating whether or not to include
    /// a comment identifying the column as a primary and/or foreign key (see example code).</param>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetTargetLanguageMethodIdentifiersAndTypes(ColumnType columnType, IncludeKeyIdentificationComment includeKeyIdentificationComment = IncludeKeyIdentificationComment.Yes)
    {
      return
        this
        .Where(column => (column.ColumnType & columnType) > 0)
        .OrderByDescending(column => column.ColumnType.HasFlag(ColumnType.ID))
        .ThenByDescending(column => column.ColumnType.HasFlag(ColumnType.PrimaryKey))
        .ThenBy(column => column.PrimaryKeyOrdinal)
        .ThenByDescending(column => column.ColumnType.HasFlag(ColumnType.ForeignKey))
        .Select(column => column.GetTargetLanguageMethodParameterNameAndType(includeKeyIdentificationComment))
        .ToList();
    }

    /// <summary>
    /// Returns a list of strings that represent a set of SqlParameter constructor declarations in the specified target language,
    /// one for each column.
    /// </summary>
    /// <example>
    /// Assuming the configuration's XmlSystem is set to Linq_XDocument, and TargetLanguage is set to CSharp,
    /// executing ""command.Parameters.Add(" + String.Join(");" + Environment.NewLine + "command.Parameters.Add(", table.Columns.GetTargetLanguageSqlParameterText()) + ");""
    /// on the AdventureWorks2012 Person.Person table will generate this string:
    /// <code>
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@BusinessEntityID", SqlDbType = System.Data.SqlDbType.Int, Value = BusinessEntityID }  /* primary key 1, foreign key */);
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@AdditionalContactInfo", SqlDbType = System.Data.SqlDbType.Xml, Value = AdditionalContactInfo.GetSqlXml() });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@Demographics", SqlDbType = System.Data.SqlDbType.Xml, Value = Demographics.GetSqlXml() });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@EmailPromotion", SqlDbType = System.Data.SqlDbType.Int, Value = EmailPromotion });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@FirstName", SqlDbType = System.Data.SqlDbType.NVarChar, Value = FirstName });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@LastName", SqlDbType = System.Data.SqlDbType.NVarChar, Value = LastName });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@MiddleName", SqlDbType = System.Data.SqlDbType.NVarChar, Value = MiddleName });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@ModifiedDate", SqlDbType = System.Data.SqlDbType.DateTime, Value = ModifiedDate });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@NameStyle", SqlDbType = System.Data.SqlDbType.Bit, Value = NameStyle });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@PersonType", SqlDbType = System.Data.SqlDbType.NChar, Value = PersonType });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@rowguid", SqlDbType = System.Data.SqlDbType.UniqueIdentifier, Value = rowguid });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@Suffix", SqlDbType = System.Data.SqlDbType.NVarChar, Value = Suffix });
    /// command.Parameters.Add(new SqlParameter() { ParameterName = "@Title", SqlDbType = System.Data.SqlDbType.NVarChar, Value = Title });
    /// </code>
    /// </example>
    /// <param name="includeKeyIdentificationComment">An enum value indicating whether or not to include
    /// <param name="includeKeyIdentificationComment">An enum value indicating whether or not to include
    /// a comment identifying the column as a primary and/or foreign key (see example code).</param>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetTargetLanguageSqlParameterText(ColumnType columnType, IncludeKeyIdentificationComment includeKeyIdentificationComment = IncludeKeyIdentificationComment.Yes)
    {
      return
        this
        .Where(column => (column.ColumnType & columnType) > 0)
        .OrderByDescending(column => column.ColumnType.HasFlag(ColumnType.ID))
        .ThenByDescending(column => column.ColumnType.HasFlag(ColumnType.PrimaryKey))
        .ThenBy(column => column.PrimaryKeyOrdinal)
        .ThenByDescending(column => column.ColumnType.HasFlag(ColumnType.ForeignKey))
        .ThenBy(column => column.Name)
        .Select(column => column.GetTargetLanguageSqlParameterText(includeKeyIdentificationComment))
        .ToList();
    }

    /// <summary>
    /// Return a list of strings that contain the backing store declarations for all of the columns in a table.
    /// <para>Since auto-properties don't require a backing store, this method returns backing store declarations
    /// for only those non-auto properties that need them.</para>
    /// </summary>
    /// <example>
    /// For the Person.Person table in AdventureWorks2012, with the configuration's TargetLanguage set to CSharp and
    /// XmlSystem set to NonLinq_XmlDocument, this method will return a list with these strings:
    /// <code>
    /// private System.Xml.XmlDocument _additionalcontactinfo;
    /// private System.Xml.XmlDocument _demographics;
    /// </code>
    /// </example>
    /// <returns>A <see cref="System.Collections.Generic.List{T}">List&lt;String&gt;</see>.</returns>
    public List<String> GetNecessaryTargetLanguageBackingStoreDeclarations()
    {
      return
        this
       .Where(column => column.DoesTargetLanguagePropertyNeedBackingStore)
       .Select(column => column.TargetLanguageBackingStoreDeclaration)
       .ToList();
    }
  }

  /// <summary>
  /// The Column class contains the majority of primitive properties and methds needed to generate
  /// TSQL, C#, F# and VB target code.
  /// </summary>
  public class Column
  {
    public Table Table { get; private set; }

    /// <summary>
    /// The column's name as it appears on the database server.
    /// </summary>
    public String Name { get; set; }

    /// <summary>
    /// The position of this column in the list of columns in the parent table or view.
    /// </summary>
    public Int32 Ordinal { get; set; }

    /// <summary>
    /// An enumeration indicating what kind of column this is.
    /// </summary>
    public ColumnType ColumnType { get; set; }

    /// <summary>
    /// The SQL Server native data type name (E.g. VARCHAR(50), INT, DATETIME, etc.), or aliased data type name (E.g. CustomerAddress, ZipCode, etc.).
    /// </summary>
    public String ServerDataTypeName { get; set; }

    /// <summary>
    /// The SQL Server native data type name.  If this column's <see cref="Utilities.Sql.Column.ServerDataTypeName">ServerDataTypeName</see> property
    /// is an aliased type name, this property will contain the underlying native data type name.  E.g. if this column has
    /// a ServerDataTypeName of "CustomerAddress", this property will contain the underlying native data type name of NVARCHAR(50).
    /// </summary>
    public String NativeServerDataTypeName { get; set; }

    /// <summary>
    /// The number of bytes the column occupies on the server.
    /// </summary>
    public Int32 PhysicalLength { get; set; }

    /// <summary>
    /// The same as <see cref="Utilities.Sql.Column.PhysicalLength">PhysicalLength</see>, unless the column's type
    /// is something like VARBINARY(MAX), N/VARCHAR(MAX) or XML.
    /// </summary>
    public Int32 LogicalLength { get; set; }

    public Int32 Precision { get; set; }
    public Int32 Scale { get; set; }
    public Boolean IsNullable { get; set; }
    public Boolean IsXmlDocument { get; set; }
    public String XmlCollectionName { get; set; }

    /// <summary>
    /// Some primary keys consist of multiple columns.  If <see cref="Utilities.Sql.Column.ColumnType">ColumnType</see> contains
    /// the PrimaryKey flag, this property
    /// indicates this column's position in the set of columns that make up the primary key.
    /// </summary>
    public Int32 PrimaryKeyOrdinal { get; set; }

    /// <summary>
    /// 'ASC' for an ascending primary key, 'DESC' for a descending primary key.
    /// An empty string if this column is not part of a primary key definition.
    /// </summary>
    public String PrimaryKeyDirection { get; set; }

    /// <summary>
    /// If <see cref="Utilities.Sql.Column.ColumnType">ColumnType</see> contains the ForeignKey flag, the name of the schema that owns the table this foreign key references.
    /// </summary>
    public String PrimaryKeySchema { get; set; }

    /// <summary>
    /// If <see cref="Utilities.Sql.Column.ColumnType">ColumnType</see> contains the ForeignKey flag, the name of the table this foreign key references.
    /// </summary>
    public String PrimaryKeyTable { get; set; }

    /// <summary>
    /// If <see cref="Utilities.Sql.Column.ColumnType">ColumnType</see> contains the ForeignKey flag, the name of the column this foreign key references.
    /// </summary>
    public String PrimaryKeyColumn { get; set; }

    private String _clrTypeName = null;
    /// <summary>
    /// The fully qualified CLR type name for this column's <see cref="Utilities.Sql.Column.NativeServerDataTypeName">NativeServerDataTypeName</see>.
    /// E.g. this property would contain System.String for a column type of NVARCHAR(50).
    /// </summary>
    public String ClrTypeName
    {
      get
      {
        if (this._clrTypeName == null)
          this._clrTypeName = this.GetClrTypeNameFromNativeSqlType();

        return this._clrTypeName;
      }
    }

    private String _sqlDbTypeEnumName = null;
    public String SqlDbTypeEnumName
    {
      get
      {
        if (this._sqlDbTypeEnumName == null)
          this._sqlDbTypeEnumName = this.GetSqlDbTypeFromNativeSqlType();

        return this._sqlDbTypeEnumName;
      }
    }

    private String _targetLanguageIdentifier = null;
    /// <summary>
    /// This column's name, converted to a valid identifier in the target language.
    /// </summary>
    public String TargetLanguageIdentifier
    {
      get
      {
        if (this._targetLanguageIdentifier == null)
          this._targetLanguageIdentifier = IdentifierHelper.GetTargetLanguageIdentifier(this.Name);

        return this._targetLanguageIdentifier;
      }
    }

    /// <summary>
    /// A simple target language identifier primarily used as the name for a property's backing store (e.g. "_customername" in "private String _customername").
    /// </summary>
    public String TargetLanguageBackingStoreIdentifier
    {
      get { return "_" + this.TargetLanguageIdentifier; }
    }

    private String _targetLanguageBackingStoreDeclaration = null;
    /// <summary>
    /// A simple target language backing store declaration.  For use when
    /// generating properties that require a backing store.  The scope of
    /// the declaration is always private (e.g. "private String _customername").
    /// </summary>
    public String TargetLanguageBackingStoreDeclaration
    {
      get
      {
        if (this._targetLanguageBackingStoreDeclaration == null)
          this._targetLanguageBackingStoreDeclaration = this.GetTargetLanguageBackingStoreDeclaration();

        return this._targetLanguageBackingStoreDeclaration;
      }
    }

    /// <summary>
    /// Sometimes the code for a particular target language's property definition returned by GetTargetLanguageProperty
    /// has a dependency on an associated backing store.
    /// This property can be used to determine whether or not TargetLanguageBackingStoreDeclaration
    /// needs to be used to place the backing store in any generated code.
    /// </summary>
    public Boolean DoesTargetLanguagePropertyNeedBackingStore
    {
      get
      {
        var isXmlRelatedProperty =
          !String.IsNullOrWhiteSpace(this.XmlCollectionName) &&
          this._configuration.XmlValidationLocation.HasFlag(XmlValidationLocation.PropertySetter);

        return !this._configuration.TargetLanguage.DoesSupportAutoProperties() || isXmlRelatedProperty;
      }
    }

    private String _sqlIdentifier = null;
    /// <summary>
    /// This column's name, converted to a valid identifier for use in TSQL.
    /// </summary>
    public String SqlIdentifier
    {
      get
      {
        if (this._sqlIdentifier == null)
          this._sqlIdentifier = "@" + this.Name.Replace(" ", "_");

        return this._sqlIdentifier;
      }
    }

    private String _sqlIdentifierTypeAndSize = null;
    /// <summary>
    /// This column's SQL Server data type name and size (if applicable).  E.g. VARCHAR(10), INT, DECIMAL(18, 5), etc.
    /// </summary>
    public String SqlIdentifierTypeAndSize
    {
      get
      {
        if (this._sqlIdentifierTypeAndSize == null)
          this._sqlIdentifierTypeAndSize = this.GetSqlParameterTypeAndSize();

        return this._sqlIdentifierTypeAndSize;
      }
    }

    private Nullable<Boolean> _isTrimmable = null;
    /// <summary>
    /// Can this column be trimmed (i.e. is this column's underlying type a string)?
    /// </summary>
    public Boolean IsTrimmable
    {
      get
      {
        if (!this._isTrimmable.HasValue)
          this._isTrimmable = this.IsDataTypeTrimmable();

        return this._isTrimmable.Value;
      }
    }

    private String _sqlExpressionToConvertToString = null;
    /// <summary>
    /// The TSQL expression to convert this column to an NVARCHAR(MAX).
    /// </summary>
    public String SqlExpressionToConvertToString
    {
      get
      {
        if (this._sqlExpressionToConvertToString == null)
          this._sqlExpressionToConvertToString = this.GetSqlExpressionToConvertToString();

        return this._sqlExpressionToConvertToString;
      }
    }

    private String _targetLanguageSqlParameterValue = null;
    /// <summary>
    /// Target language expression to assign this column to the Value property of an <see cref="System.Data.SqlClient.SqlParameter">SqlParameter</see> instance.
    /// </summary>
    public String TargetLanguageSqlParameterValue
    {
      get
      {
        if (this._targetLanguageSqlParameterValue == null)
          this._targetLanguageSqlParameterValue = this.GetTargetLanguageSqlParameterValue();

        return this._targetLanguageSqlParameterValue;
      }
    }

    public XmlNodeType XmlNodeType
    {
      get
      {
        return (this.IsXmlDocument ? XmlNodeType.Document : XmlNodeType.DocumentFragment);
      }
    }

    private String _keyIdentificationComment = null;
    /// <summary>
    /// It can be helpful to annotate the generated code of primary and foreign key columns with a comment, simply because of their importance.
    /// <para>This property contains such a comment for this column.  For primary keys, the comment will contain the text "primary key"
    /// followed by a number indicating the column's position within a multipart key.  For foreign keys, the comment simply contains
    /// the text "foreign key".  For columns that are both a primary and foreign key, the comment will contain both kinds of text.</para>
    /// </summary>
    public String KeyIdentificationComment
    {
      get
      {
        if (this._keyIdentificationComment == null)
          this._keyIdentificationComment = this.GetKeyIdentificationComment();

        return this._keyIdentificationComment;
      }
    }

    private Configuration _configuration;

    public Column(Table table)
      : base()
    {
      this.Table = table;
      this._configuration = table.Schema.Database.Server.Configuration;
    }

    /// <summary>
    /// An expression that compares this column's Name property with its SqlIdentifier property.
    /// <para>This expression is valid TSQL and can be used in a WHERE clause.</para>
    /// </summary>
    /// <param name="tableAlias">An optional string representing a table alias that will be prepended to the column name.</param>
    /// <returns>A String</returns>
    public String GetSqlWhereClause(String tableAlias = "")
    {
      String format = "";

      switch (this.NativeServerDataTypeName)
      {
        case "GEOGRAPHY":
        case "GEOMETRY":
          format = "({0}[{1}].STEquals({2}) = 1)";
          break;
        case "HIERARCHYID":
        case "IMAGE":
          format = "CAST({0}[{1}] AS VARBINARY(MAX)) = CAST({2} AS VARBINARY(MAX))";
          break;
        case "NTEXT":
        case "TEXT":
          format = "CAST({0}[{1}] AS NVARCHAR(MAX)) = CAST({2} AS NVARCHAR(MAX))";
          break;
        default:
          format = "{0}[{1}] = {2}";
          break;
      }

      return String.Format(format, (String.IsNullOrWhiteSpace(tableAlias) ? "" : tableAlias + "."), this.Name, this.SqlIdentifier);
    }

    private String GetClrTypeNameFromNativeSqlType()
    {
      Func<String, String> getAppropriateClrType =
        clrType =>
        {
          if (this._configuration.TargetLanguage.IsCSharp() || this._configuration.TargetLanguage.IsFSharp())
            return this.IsNullable ? "System.Nullable<System." + clrType + ">" : "System." + clrType;
          else if (this._configuration.TargetLanguage.IsVisualBasic())
            return this.IsNullable ? "System.Nullable(Of System." + clrType + ")" : "System." + clrType;
          else
            throw new NotImplementedException(String.Format(Properties.Resources.UnknownTargetLanguageValue, this._configuration.TargetLanguage));
        };

      switch (this.NativeServerDataTypeName)
      {
        case "BIGINT":
          return getAppropriateClrType("Int64");
        case "BINARY":
        case "FILESTREAM":
        case "IMAGE":
        case "ROWVERSION":
        case "TIMESTAMP":
        case "VARBINARY":
          if (this._configuration.TargetLanguage.IsCSharp() || this._configuration.TargetLanguage.IsFSharp())
            return "System.Byte[]";
          else if (this._configuration.TargetLanguage.IsVisualBasic())
            return "System.Byte()";
          else
            throw new NotImplementedException(String.Format(Properties.Resources.UnknownTargetLanguageValue, this._configuration.TargetLanguage));
        case "BIT":
          return getAppropriateClrType("Boolean");
        case "CURSOR":
          return "";
        case "DATE":
        case "DATETIME":
        case "DATETIME2":
        case "SMALLDATETIME":
          return getAppropriateClrType("DateTime");
        case "DATETIMEOFFSET":
          return getAppropriateClrType("DateTimeOffset");
        case "DECIMAL":
        case "MONEY":
        case "NUMERIC":
        case "SMALLMONEY":
          return getAppropriateClrType("Decimal");
        case "FLOAT":
          return getAppropriateClrType("Double");
        case "GEOGRAPHY":
          return "Microsoft.SqlServer.Types.SqlGeography";
        case "GEOMETRY":
          return "Microsoft.SqlServer.Types.SqlGeometry";
        case "HIERARCHYID":
          return "Microsoft.SqlServer.Types.SqlHierarchyId";
        case "INT":
          return getAppropriateClrType("Int32");
        case "CHAR":
        case "NCHAR":
        case "NTEXT":
        case "NVARCHAR":
        case "TEXT":
        case "VARCHAR":
          return "System.String";
        case "XML":
          switch (this._configuration.XmlSystem)
          {
            case XmlSystem.AsString:
              return "System.String";
            case XmlSystem.Linq_XDocument:
              if (this.IsXmlDocument)
                return "System.Xml.Linq.XDocument";
              else
                return "System.Xml.Linq.XElement";
            case XmlSystem.NonLinq_XmlDocument:
              return "System.Xml.XmlDocument";
            default:
              return String.Format(Properties.Resources.UnknownXmlSystemValue, this._configuration.XmlSystem);
          }
        case "REAL":
          return getAppropriateClrType("Single");
        case "SMALLINT":
          return getAppropriateClrType("Int16");
        case "SQL_VARIANT":
          return "System.Object";
        case "TIME":
          return getAppropriateClrType("TimeSpan");
        case "TINYINT":
          return getAppropriateClrType("Byte");
        case "UNIQUEIDENTIFIER":
          return getAppropriateClrType("Guid");
        default:
          return String.Format("ERROR - Can't find CLR type that corresponds to SQL Server type {0}.", this.NativeServerDataTypeName);
      }
    }

    /// <summary>
    /// Given the name of an SqlDataReader instance, return an expression that can be used
    /// to safely get the column's value out of the reader.
    /// </summary>
    /// <param name="readerName">The name of an SqlDataReader instance.</param>
    /// <returns>A String.</returns>
    public String GetTargetLanguageDataReaderExpression(String readerName)
    {
      if (this._configuration.TargetLanguage.IsCSharp() || this._configuration.TargetLanguage.IsFSharp())
        return String.Format("{0}.GetValueOrDefault<{1}>(\"{2}\")", readerName, this.ClrTypeName, this.Name);
      else if (this._configuration.TargetLanguage.IsVisualBasic())
        return String.Format("{0}.GetValueOrDefault(Of {1})(\"{2}\")", readerName, this.ClrTypeName, this.Name);
      else
        throw new NotImplementedException(String.Format(Properties.Resources.UnknownTargetLanguageValue, this._configuration.TargetLanguage));
    }

    private String GetSqlDbTypeFromNativeSqlType()
    {
      var result = "";

      /* Some of this code may look redundant, but the case of the returned
         string is important. This is because the text returned by this function
         will be used to generate source code, probably for a case-sensitive language
         like C#. */

      switch (this.NativeServerDataTypeName.ToUpper())
      {
        case "BIGINT":
          result = "BigInt";
          break;
        case "BINARY":
        case "FILESTREAM":
        case "VARBINARY":
          result = "VarBinary";
          break;
        case "ROWVERSION":
        case "TIMESTAMP":
          result = "Timestamp";
          break;
        case "BIT":
          result = "Bit";
          break;
        case "GEOGRAPHY":
        case "GEOMETRY":
        case "HIERARCHYID":
          result = "Udt";
          break;
        case "DATE":
          result = "Date";
          break;
        case "DATETIME":
        case "SMALLDATETIME":
          result = "DateTime";
          break;
        case "DATETIME2":
          result = "DateTime2";
          break;
        case "DATETIMEOFFSET":
          result = "DateTimeOffset";
          break;
        case "DECIMAL":
        case "NUMERIC":
          result = "Decimal";
          break;
        case "MONEY":
          result = "Money";
          break;
        case "SMALLMONEY":
          result = "SmallMoney";
          break;
        case "FLOAT":
          result = "Float";
          break;
        case "IMAGE":
          result = "Binary";
          break;
        case "INT":
          result = "Int";
          break;
        case "CHAR":
          result = "Char";
          break;
        case "NCHAR":
          result = "NChar";
          break;
        case "NTEXT":
          result = "NText";
          break;
        case "NVARCHAR":
          result = "NVarChar";
          break;
        case "TEXT":
          result = "Text";
          break;
        case "VARCHAR":
          result = "VarChar";
          break;
        case "XML":
          result = "Xml";
          break;
        case "REAL":
          result = "Real";
          break;
        case "SMALLINT":
          result = "SmallInt";
          break;
        case "SQL_VARIANT":
          result = "Variant";
          break;
        case "TIME":
          result = "Time";
          break;
        case "TINYINT":
          result = "TinyInt";
          break;
        case "UNIQUEIDENTIFIER":
          result = "UniqueIdentifier";
          break;
        default:
          result = "";
          break;
      }

      if (!String.IsNullOrWhiteSpace(result))
        return "System.Data.SqlDbType." + result;
      else
        return "";
    }

    private String GetSqlParameterTypeAndSize()
    {
      switch (this.ServerDataTypeName)
      {
        case "DATETIME2":
        case "DATETIMEOFFSET":
        case "TIME":
          return String.Format("{0}({1})", this.ServerDataTypeName, this.Scale);

        case "DECIMAL":
        case "NUMERIC":
          return String.Format("{0}({1}, {2})", this.ServerDataTypeName, this.Precision, this.Scale);

        case "VARBINARY":
        case "VARCHAR":
        case "NVARCHAR":
          return String.Format("{0}({1})", this.ServerDataTypeName, (this.LogicalLength == -1 ? "MAX" : this.LogicalLength.ToString()));

        case "BINARY":
        case "CHAR":
        case "NCHAR":
          return String.Format("{0}({1})", this.ServerDataTypeName, this.LogicalLength);

        case "XML":
          if (String.IsNullOrWhiteSpace(this.XmlCollectionName))
            return this.ServerDataTypeName;
          else
            return String.Format("{0}({1}, {2})", this.ServerDataTypeName, this.IsXmlDocument ? "DOCUMENT" : "CONTENT", this.XmlCollectionName);

        default:
          return this.ServerDataTypeName;
      }
    }

    private Boolean IsDataTypeTrimmable()
    {
      return "CHAR/VARCHAR/NCHAR/NVARCHAR/TEXT/NTEXT".Contains(this.NativeServerDataTypeName);
    }

    private String GetSqlExpressionToConvertToString()
    {
      switch (this.NativeServerDataTypeName)
      {
        case "CHAR":
        case "NCHAR":
        case "NVARCHAR":
        case "SYSNAME":
        case "TIMESTAMP":
        case "VARCHAR":
          return this.SqlIdentifier;

        case "BIGINT":
        case "BIT":
        case "DATE":
        case "DATETIME2":
        case "DATETIMEOFFSET":
        case "DECIMAL":
        case "FLOAT":
        case "INT":
        case "MONEY":
        case "NTEXT":
        case "NUMERIC":
        case "REAL":
        case "SMALLINT":
        case "SMALLMONEY":
        case "TEXT":
        case "TINYINT":
        case "UNIQUEIDENTIFIER":
        case "XML":
          return String.Format("CONVERT(NVARCHAR(MAX), {0})", this.SqlIdentifier);

        case "DATETIME":
        case "SMALLDATETIME":
          return String.Format("CONVERT(NVARCHAR(MAX), {0}, 121)", this.SqlIdentifier);

        case "TIME":
          return String.Format("CONVERT(NVARCHAR(MAX), {0}, 14)", this.SqlIdentifier);

        case "GEOGRAPHY":
        case "GEOMETRY":
          return String.Format("{0}.STAsText()", this.SqlIdentifier);

        case "HIERARCHYID":
          return String.Format("{0}.ToString()", this.SqlIdentifier);

        case "BINARY":
        case "IMAGE":
        case "VARBINARY":
          return String.Format("'{0} with length ' + CONVERT(NVARCHAR(MAX), DATALENGTH({1})) + '.'", this.NativeServerDataTypeName, this.SqlIdentifier);

        case "SQL_VARIANT":
          return String.Format("dbo.util_Get_SqlVariant_As_NVarCharMax({0})", this.SqlIdentifier);

        default:
          return String.Format("Don't know how to convert type {0} to a string.", this.NativeServerDataTypeName);
      }
    }

    /// <summary>
    /// Returns a string that can be used in generated code to create a new SqlParameter instance for this column.
    /// </summary>
    /// <param name="includeKeyIdentificationComment">An enum value indicating whether or not to include
    /// a comment identifying the column as a primary and/or foreign key.</param>
    /// <returns>A String.</returns>
    public String GetTargetLanguageSqlParameterText(IncludeKeyIdentificationComment includeKeyIdentificationComment = IncludeKeyIdentificationComment.Yes)
    {
      var comment = (((includeKeyIdentificationComment == IncludeKeyIdentificationComment.Yes) && this.KeyIdentificationComment.Trim().Any()) ? " " + this.KeyIdentificationComment : "");

      if (this._configuration.TargetLanguage.IsCSharp())
      {
        if (this.SqlDbTypeEnumName == "System.Data.SqlDbType.Udt")
          return String.Format("new SqlParameter() {{ ParameterName = \"{0}\", SqlDbType = {1}, UdtTypeName = \"{2}\", Value = {3} }}{4}",
            this.SqlIdentifier, this.SqlDbTypeEnumName, this.NativeServerDataTypeName, this.TargetLanguageSqlParameterValue, comment).Trim();
        else
          return String.Format("new SqlParameter() {{ ParameterName = \"{0}\", SqlDbType = {1}, Value = {2} }}{3}",
            this.SqlIdentifier, this.SqlDbTypeEnumName, this.TargetLanguageSqlParameterValue, comment).Trim();
      }
      else if (this._configuration.TargetLanguage.IsFSharp())
      {
        if (this.SqlDbTypeEnumName == "System.Data.SqlDbType.Udt")
          return String.Format("new SqlParameter(ParameterName = \"{0}\", SqlDbType = {1}, UdtTypeName = \"{2}\", Value = {3}){4}",
            this.SqlIdentifier, this.SqlDbTypeEnumName, this.NativeServerDataTypeName, this.TargetLanguageSqlParameterValue, comment).Trim();
        else
          return String.Format("new SqlParameter(ParameterName = \"{0}\", SqlDbType = {1}, Value = {2}){3}",
            this.SqlIdentifier, this.SqlDbTypeEnumName, this.TargetLanguageSqlParameterValue, comment).Trim();
      }
      else if (this._configuration.TargetLanguage.IsVisualBasic())
      {
        if (this.SqlDbTypeEnumName == "System.Data.SqlDbType.Udt")
          return String.Format("new SqlParameter() With {{ .ParameterName = \"{0}\", .SqlDbType = {1}, .UdtTypeName = \"{2}\", .Value = {3} }}{4}",
            this.SqlIdentifier, this.SqlDbTypeEnumName, this.NativeServerDataTypeName, this.TargetLanguageSqlParameterValue, comment).Trim();
        else
          return String.Format("new SqlParameter() With {{ .ParameterName = \"{0}\", .SqlDbType = {1}, .Value = {2} }}{3}",
            this.SqlIdentifier, this.SqlDbTypeEnumName, this.TargetLanguageSqlParameterValue, comment).Trim();
      }
      else
        throw new NotImplementedException(String.Format(Properties.Resources.UnknownTargetLanguageValue, this._configuration.TargetLanguage));
    }

    private String GetTargetLanguageSqlParameterValue()
    {
      if (this.ServerDataTypeName == "XML")
        switch (this._configuration.XmlSystem)
        {
          case XmlSystem.AsString:
          case XmlSystem.Linq_XDocument:
            return String.Format("{0}.GetSqlXml()", this.TargetLanguageIdentifier);
          case XmlSystem.NonLinq_XmlDocument:
            return String.Format("{0}.GetSqlXml(XmlNodeType.{1})", this.TargetLanguageIdentifier, this.XmlNodeType);
          default:
            return String.Format(Properties.Resources.UnknownXmlSystemValue, this._configuration.XmlSystem);
        }
      else
        return this.TargetLanguageIdentifier;
    }

    private String GetKeyIdentificationComment()
    {
      var comments = new List<String>();

      if (this.ColumnType.HasFlag(ColumnType.ID))
        comments.Add("identity");

      if (this.ColumnType.HasFlag(ColumnType.PrimaryKey))
        comments.Add(String.Format("primary key {0}", this.PrimaryKeyOrdinal));

      if (this.ColumnType.HasFlag(ColumnType.ForeignKey))
        comments.Add(String.Format("foreign key ({0}.{1}({2}))", this.PrimaryKeySchema, this.PrimaryKeyTable, this.PrimaryKeyColumn));

      var format = "";

      if (this._configuration.TargetLanguage.IsCSharp())
        format = "/* {0} */";
      else if (this._configuration.TargetLanguage.IsFSharp())
        format = "(* {0} *)";
      else if (this._configuration.TargetLanguage.IsVisualBasic())
        format = "' {0}";
      else
        throw new NotImplementedException(String.Format(Properties.Resources.UnknownTargetLanguageValue, this._configuration.TargetLanguage));

      return (comments.Count == 0) ? "" : String.Format(format, String.Join(", ", comments));
    }

    /// <summary>
    /// Return a string that can be used in generated code to represent this column as a target language method parameter.
    /// </summary>
    /// <param name="includeKeyIdentificationComment">An enum value indicating whether or not to include
    /// a comment identifying the column as a primary and/or foreign key.</param>
    /// <returns>A String.</returns>
    public String GetTargetLanguageMethodParameterNameAndType(IncludeKeyIdentificationComment includeKeyIdentificationComment = IncludeKeyIdentificationComment.Yes)
    {
      var format = "";

      if (this._configuration.TargetLanguage.IsCSharp())
        format = "{0} {1}{2}";
      else if (this._configuration.TargetLanguage.IsFSharp())
        format = "({1} : {0}{2})";
      else if (this._configuration.TargetLanguage.IsVisualBasic())
        format = "{1} As {0}{2}";
      else
        throw new NotImplementedException(String.Format(Properties.Resources.UnknownTargetLanguageValue, this._configuration.TargetLanguage));

      return String.Format(format, this.ClrTypeName, this.TargetLanguageIdentifier,
        (((includeKeyIdentificationComment == IncludeKeyIdentificationComment.Yes) && this.KeyIdentificationComment.Trim().Any()) ? " " + this.KeyIdentificationComment : "")).Trim();
    }

    private String GetTargetLanguageBackingStoreDeclaration()
    {
      if (this._configuration.TargetLanguage.IsCSharp())
        return String.Format("private {0} {1};", this.ClrTypeName, this.TargetLanguageBackingStoreIdentifier);
      else if (this._configuration.TargetLanguage.IsFSharp())
        return String.Format("let mutable {1} = Unchecked.defaultof<{0}>", this.ClrTypeName, this.TargetLanguageBackingStoreIdentifier);
      else if (this._configuration.TargetLanguage.IsVisualBasic())
        return String.Format("Private Dim {1} As {0}", this.ClrTypeName, this.TargetLanguageBackingStoreIdentifier);
      else
        throw new NotImplementedException(String.Format(Properties.Resources.UnknownTargetLanguageValue, this._configuration.TargetLanguage));
    }

    /// <summary>
    /// Return a string that can be used in generated code to represent this column as a target language class property declaration.
    /// </summary>
    /// <param name="scope"></param>
    /// <param name="includeKeyIdentificationComment">An enum value indicating whether or not to include
    /// a comment identifying the column as a primary and/or foreign key.</param>
    /// <returns>A String.</returns>
    public String GetTargetLanguageProperty(String scope, IncludeKeyIdentificationComment includeKeyIdentificationComment = IncludeKeyIdentificationComment.Yes)
    {
      var keyIdentificationComment = ((includeKeyIdentificationComment == IncludeKeyIdentificationComment.Yes) && this.KeyIdentificationComment.Trim().Any()) ? this.KeyIdentificationComment : "";
      var targetLanguage = this._configuration.TargetLanguage;

      if (String.IsNullOrWhiteSpace(this.XmlCollectionName) || !this._configuration.XmlValidationLocation.HasFlag(XmlValidationLocation.PropertySetter))
      {
        var format = "";

        if (targetLanguage.IsCSharp())
        {
          if (targetLanguage.DoesSupportAutoProperties())
            format = "{0} {1} {2} {{ get; set; }} {3}";
          else
            format = @"
{3}
{0} {1} {2}
{{
  get {{ return this.{4}; }}
  set {{ this.{4} = value; }}
}}
";
        }
        else if (targetLanguage.IsFSharp())
        {
          if (targetLanguage.DoesSupportAutoProperties())
            format = "member val {0} {2} = Unchecked.defaultof<{1}> with get, set {3}";
          else
            format = @"
{3}
member {0} this.{2} with get() = {4}
member {0} this.{2} with set value = {4} <- value
";
        }
        else if (targetLanguage.IsVisualBasic())
        {
          if (targetLanguage.DoesSupportAutoProperties())
            format = "{0} Property {2}() As {1} {3}";
          else
            format = @"
{3}
{0} Property {2}() As {1}
  Get
    Return {4}
  End Get
  Set (Value As {1})
    {4} = value
  End Set
End Property
";
        }
        else
          throw new NotImplementedException(String.Format(Properties.Resources.UnknownTargetLanguageValue, this._configuration.TargetLanguage));

        return String.Format(format, scope, this.ClrTypeName, this.TargetLanguageIdentifier, keyIdentificationComment, this.TargetLanguageBackingStoreIdentifier);
      }
      else
      {
        if (this._configuration.TargetLanguage.IsCSharp())
          return this.GetXmlValidatedPropertyForCSharp(scope, keyIdentificationComment);
        else if (this._configuration.TargetLanguage.IsFSharp())
          return this.GetXmlValidatedPropertyForFSharp(scope, keyIdentificationComment);
        else if (this._configuration.TargetLanguage.IsVisualBasic())
          return this.GetXmlValidatedPropertyForVisualBasic(scope, keyIdentificationComment);
        else
          throw new NotImplementedException(String.Format(Properties.Resources.UnknownTargetLanguageValue, this._configuration.TargetLanguage));
      }
    }

    private String GetXmlValidatedPropertyForCSharp(String scope, String keyIdentificationComment)
    {
      var propertyTemplate = @"
{3}
{0} {1} {2}
{{
  get
  {{
    return this.{4};
  }}
  set
  {{
    var xsd = SqlXmlSchemas.Instance.GetXmlSchemaSet(""{5}"", ""{6}"", ""{7}"");
    {8}
    this.{4} = value;
  }}
}}
";
      String xmlValidationCode = null;

      switch (this._configuration.XmlSystem)
      {
        case XmlSystem.AsString:
          xmlValidationCode = @"
if (xsd != null)
{
  var xDocument = XDocument.Parse(value);
  xDocument.Validate(xsd, null);
}
";
          break;

        case XmlSystem.Linq_XDocument:
          xmlValidationCode = @"
if (xsd != null)
{
  value.Validate(xsd, null);
}
";
          break;

        case XmlSystem.NonLinq_XmlDocument:
          xmlValidationCode = @"
if (xsd != null)
{
  value.Schemas = xsd;
  value.Validate(null);
}
";
          break;

        default:
          throw new NotImplementedException(String.Format(Properties.Resources.UnknownXmlSystemValue, this._configuration.XmlSystem));
      }

      var schema = this.Table.Schema;

      return String.Format(propertyTemplate, scope, this.GetClrTypeNameFromNativeSqlType(), this.TargetLanguageIdentifier, keyIdentificationComment,
        this.TargetLanguageBackingStoreIdentifier, schema.Database.Name, schema.Name, this.XmlCollectionName, xmlValidationCode.Indent(4));
    }

    private String GetXmlValidatedPropertyForFSharp(String scope, String keyIdentificationComment)
    {
      var propertyTemplate = @"
{0}
member {1} this.{2} with get() = {3}
member {1} this.{2}
  with set value =
    let xsd = SqlXmlSchemas.Instance.GetXmlSchemaSet(""{4}"", ""{5}"", ""{6}"")
    {7}
    {3} <- value
";
      String xmlValidationCode = null;

      switch (this._configuration.XmlSystem)
      {
        case XmlSystem.AsString:
          xmlValidationCode = @"
if xsd <> null
  let xDocument = XDocument.Parse(value)
  xDocument.Validate(xsd, null)
";
          break;

        case XmlSystem.Linq_XDocument:
          xmlValidationCode = @"
if xsd <> null
  value.Validate(xsd, null)
";
          break;

        case XmlSystem.NonLinq_XmlDocument:
          xmlValidationCode = @"
if xsd <> null
  value.Schemas <- xsd
  value.Validate(null)
";
          break;

        default:
          throw new NotImplementedException(String.Format(Properties.Resources.UnknownXmlSystemValue, this._configuration.XmlSystem));
      }

      var schema = this.Table.Schema;

      return String.Format(propertyTemplate, keyIdentificationComment, scope, this.TargetLanguageIdentifier, this.TargetLanguageBackingStoreIdentifier,
        schema.Database.Name, schema.Name, this.XmlCollectionName, xmlValidationCode.Indent(4));
    }

    private String GetXmlValidatedPropertyForVisualBasic(String scope, String keyIdentificationComment)
    {
      var propertyTemplate = @"
{0}
{1} Property {2}() As {3}
  Get
    Return {4}
  End Get
  Set (Value As {3})
    Dim xsd As XmlSchemaSet = SqlXmlSchemas.Instance.GetXmlSchemaSet(""{5}"", ""{6}"", ""{7}"")
    {8}
    {4} = value
  End Set
End Property
";
      String xmlValidationCode = null;

      switch (this._configuration.XmlSystem)
      {
        case XmlSystem.AsString:
          xmlValidationCode = @"
If xsd IsNot Nothing Then
  Dim xDocument As XDocument = XDocument.Parse(value)
  xDocument.Validate(xsd, Null)
End If
";
          break;

        case XmlSystem.Linq_XDocument:
          xmlValidationCode = @"
If xsd IsNot Nothing Then
  value.Validate(xsd, Null)
End If
";
          break;

        case XmlSystem.NonLinq_XmlDocument:
          xmlValidationCode = @"
If xsd IsNot Nothing Then
  value.Schemas = xsd
  value.Validate(Null)
End If
";
          break;

        default:
          throw new NotImplementedException(String.Format(Properties.Resources.UnknownXmlSystemValue, this._configuration.XmlSystem));
      }

      var schema = this.Table.Schema;

      return String.Format(propertyTemplate, keyIdentificationComment, scope, this.TargetLanguageIdentifier, this.GetClrTypeNameFromNativeSqlType(),
        this.TargetLanguageBackingStoreIdentifier, schema.Database.Name, schema.Name, this.XmlCollectionName, xmlValidationCode.Indent(4));
    }

    /// <summary>
    /// Return a string that can be used in generated code to represent this column as a TSQL stored procedure parameter.
    /// </summary>
    /// <param name="includeKeyIdentificationComment">An enum value indicating whether or not to include
    /// a comment identifying the column as a primary and/or foreign key.</param>
    /// <returns>A String.</returns>
    public String GetStoredProcedureParameterDeclaration(IncludeKeyIdentificationComment includeKeyIdentificationComment = IncludeKeyIdentificationComment.Yes)
    {
      return String.Format("{0} {1}{2}", this.SqlIdentifier, this.SqlIdentifierTypeAndSize,
        ((includeKeyIdentificationComment == IncludeKeyIdentificationComment.Yes) && this.KeyIdentificationComment.Trim().Any()) ? " " + this.KeyIdentificationComment : "");
    }

    public String GetCreateTableColumnDeclaration()
    {
      return String.Format("[{0}] {1}{2}", this.Name, this.SqlIdentifierTypeAndSize, this.IsNullable ? " NULL" : "");
    }
  }
}
